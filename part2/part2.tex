\documentclass[../gr-final.tex]{subfiles}
\begin{document}
\lstset{language=Haskell}
%\subfile{chap1}
\part{Results}
\chapter{System Implementation}

\paragraph{} The system in this report is a reasoning system using a
propositional logic with user-defined linear symmetrical hedge algebra
as the domain of truth value. The reasoning method to be used is the
aforementioned Alpha Resolution in the previous part.
	
\paragraph{} The main objective of implementing this system is to demonstrate the applicability and feasibility of automated linguistic logic reasoning systems based on linear symmetrical hedge algebra, to design and implement a system for developing knowledge bases capable of capturing fuzzy linguistic 
concepts, using user-defined LSHA-based truth value domain, as an alternative to traditional fuzzy logic knowledge base.



\section{Problem Definition}

\paragraph{}Essentially, the problem to be solved by this system is,
with a user-defined linear symmetrical hedge algebra (LSHA) as a truth value
domain, a knowledgebase in the form of hedge algebra based
propositional CNF  clauses, if a user had a proposition of the form
\(A^{truth-value}\), the system should be able to tell if this
proposition is true or not, and with as much confidence as it could guarantee.\\
In addition, the system must also provide the
functionality to create, update and manage knowledgebase and
hedge algebra definition. 

\paragraph{}The input of the program is a database describing the hedge algebra to be used, and another database where the knowledge base is stored.\\
The hedge definition including the tables below:
\begin{itemize}
\item A table defining the hedges of the LSHA, containing each hedge's
  unique name and id.
\item Two tables for the positive/negative hedges, and their precedence/ranking.
\item Two tables defining the positive and negative relationships 
  between hedges.
\end{itemize}

\paragraph{}The generator terms of the hedge algebras are always True
and False, so they don't need to be specified in the truth domain's
definition. There are also two other truth constant: Maxt for the
maximum truth value, and Mint for the minimum truth value, regardless
of the set of hedges.\\ 

\paragraph{}The knowledgebase database including:

\begin{itemize}
\item A table describing disjunctive clauses, including their id and
  optionally their label. 
\item A table of literals used in the KB's clauses, with their id,
  name, and two columns to determine their truth value supscribe: sid
  is a reference to the table of sequences of hedges, and seed is one
  of the four generator terms: True, False, Maxt or Mint.
\item A table describing sequences of hedges, including their id,
  their ``head'' hedge's id, and their ``tail'' sequences of hedges
  id, which is a reference to this table itself. 
\item A table relating clauses with the literals they use, with two
  columns being reference to clauses table and literals table, respectively
\end{itemize}

\paragraph{} The Output is either a linguistic truth value, which is
the confidence of the resolution process on the queried clause, or
literally a Nothing value if that clause were unprovable.

\section{High level Requirements}
\subsection{Functional Requirements}
\begin{itemize}
\item Enable user defined hedge algebra structure, and allow user to
  manage the definition of said structure.
\item Enforcing hedge algebra laws on the user defined hedges
\item Allow user to use, create and manage fuzzy knowledgebase
\item Able to answer user's query by proving it
\end{itemize}

\subsection{Non- Functional Requirements}
\begin{itemize}
\item Acceptable performance
\item Easy to use
\end{itemize}

\subsection{Quality Attributes}

\paragraph{Correctness:}
The reasoning process must be {\em sound} and {\em complete}.

\paragraph{Maintainability:}
The system should be easy to maintain and extend

\section{System configuration}

\paragraph{}The programming language being used is Haskell, a purely functional programming language. The particular implementation of Haskell used for this system is the Glasgow  Haskell Compiler v.7.4.2 on Linux.

\paragraph{}The database management system of choice is the lightweight embedded DMBS SQLite3. 

\paragraph{}The system also makes use of some external Haskell libraries: 

\begin{itemize}
\item HDBC, the Haskell Database Connectivity library
\item HDBC.SQLite3, SQLite3's backend for HDBC. This library implies
  the presence of Sqlite3.
\item Readline, for a little better I/O in the
  commandline mode. Likewise this library also requires readline
  already on the system
\item Template Haskell, a metaprogramming library for Haskell
\item SelfRestart, a very small library providing the ability for a
  process to restart itself. Unlike other library mentioned here, this
  one is included in the source of the program so there's no need to
  install it beforehand. Its description will not be included in
  the design, however.
  
\end{itemize}



\section{System Design}
\subsection{Database Design}

\begin{figure}[H]
\includegraphics[scale=0.45]{part2/ERDiagram}
\caption{Entity-relationship diagram modeling the relation
between data of the system}
\end{figure}
\subsubsection{Database schema}
\paragraph{}

%\begin{figure}[H]
%\includegraphics[clip=true, trim = 90 0 0 0,
%scale=0.8,page=1]{part2/DataModel}
%\end{figure}
%\begin{figure}[H]
%\includegraphics[clip=true, trim = 90 200 0 0,
%scale=0.8,page=2]{part2/DataModel}
%\caption{Database schema of the system}
%\end{figure}

\begin{table}[H]
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
      No & Column name & Private key & Foreign key & Unique & Data type   & Description   \\ \hline
      1  & HID         & X           & ~           & X      & Numeric     & ID of a hedge \\ \hline
      2  & Name        & ~           & ~           & X      & Varchar(60) & Hedge name    \\ \hline
\end{tabular}
\caption {Table hedges}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID         & ~           & X           & X      & Numeric   & ID of a hedge         \\ \hline
    2  & precedence  & ~           & ~           & X      & Numeric   & For determining order \\ \hline
    \end{tabular}
    \caption {Table posl (Positive hedge list)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID         & ~           & X           & X      & Numeric   & ID of a hedge         \\ \hline
    2  & precedence  & ~           & ~           & X      & Numeric   & For determining order \\ \hline
    \end{tabular}
    \caption {Table negl (Negative hedge list)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID1        & ~           & X           & ~      & Numeric   & ID of affecting hedge \\ \hline
    2  & HID2        & ~           & X           & ~      & Numeric   & ID of affected hedge  \\ \hline
    \end{tabular}
    \caption {Table posrel (Positive relation matrix)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID1        & ~           & X           & ~      & Numeric   & ID of affecting hedge \\ \hline
    2  & HID2        & ~           & X           & ~      & Numeric   & ID of affected hedge  \\ \hline
    \end{tabular}
    \caption {Table negrel (Negative relation matrix)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type    & Description    \\ \hline
    1  & CID         & X           & ~           & X      & Numeric      & ID of a Clause \\ \hline
    2  & label       & ~           & ~           & ~      & Varchar(256) & Optional label \\ \hline
    \end{tabular}
    \caption {Table conj (Clauses of the knowledge base )}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type    & Description                           \\ \hline
    1  & LID         & X           & ~           & X      & Numeric      & ID of a literal                       \\ \hline
    2  & sentence    & ~           & ~           & ~      & Varchar(256) & literal's sentence                    \\ \hline
    3  & SID         & ~           & X           & ~      & Numeric      & ID of a hedge string                  \\ \hline
    4  & genterm     & ~           & ~           & ~      & Varchar(20)  & A fuzzy truth value's generator term \\ \hline
    \end{tabular}
    \caption {Table literal (Literals of the clauses of the knowledge base )}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description     \\ \hline
    1  & CID         & X           & X           & ~      & Numeric   & ID of a Clause  \\ \hline
    2  & LID         & X           & X           & ~      & Numeric   & ID of a literal \\ \hline
    \end{tabular}
    \caption {Table conjLits (Literals - Clauses many-to-many relationship)}
\end{table}


\begin{table}[H]
                \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description                                    \\ \hline
    1  & SID         & X           & ~           & X      & Numeric   & ID of a hedge string                           \\ \hline
    2  & HID         & ~           & X           & ~      &
    Numeric   & \parbox{2cm}{ID of \\the `head'\\ hedge of \\this
    hedge string} \\ \hline
    3  & tail        & X           & X           & ~      & Numeric   & ID of the `tail' hedge string                 \\ \hline
    \end{tabular}
    \caption {Table hstring (hedges in truth value of literals)}
\end{table}

\paragraph{hedges and positive/negative tables:}
The hedges table containing all hedges that was defined in the database, but
in actuallity the system will only consider those actually present in
the positive and negative tables, since any hedge must either be
positive or negative, but can't be neither.
\paragraph{} The system also prevents users from adding a hedge to both tables, to
guarantee that a hedge would not be both positive and negative.
\paragraph{} The precedence column in these tables indicate the order of hedge, the
smaller the precedence the stronger the hedge is w.r.t. other hedge in
the same list. To preserve the consistency of ordering in the two
positive/negative tables, two triggers are defined for each
table:\\
\begin{lstlisting}
CREATE TRIGGER posl_delete  
AFTER DELETE ON posl  
BEGIN
UPDATE posl SET pred = pred - 1          
WHERE posl.pred >= OLD.pred 
      AND posl.hid != OLD.hid;
END;

CREATE TRIGGER posl_insert   
AFTER INSERT ON posl   
BEGIN
UPDATE posl SET pred = pred + 1
WHERE posl.pred >= NEW.pred 
      AND posl.hid != NEW.hid;  
END;
_______________________________

CREATE TRIGGER negl_delete  
AFTER DELETE ON negl  
BEGIN
UPDATE negl SET pred = pred - 1
WHERE negl.pred >= OLD.pred 
      AND negl.hid != OLD.hid;  
END;

CREATE TRIGGER negl_insert   
AFTER INSERT ON negl   
BEGIN
UPDATE negl SET pred = pred + 1        
WHERE negl.pred >= NEW.pred 
      AND negl.hid != NEW.hid;  
END;
\end{lstlisting}

\paragraph{positive/negative relation:}
The user is also restricted to only modify one of these two tables at
a time, since doing both would likely to result in conflicts: remember
that a hedge is either positive or negative to {\em every} other
hedges. 
Once a table is updated, the other table is recalculated and updated
by the system to preserve hedge algebra's consistency.
\paragraph{Clauses and literals:}
These are pretty much just like described in the {\em Problem
  Definition} section. The system would automatically insert new
literals as necessary when updating clauses, or adding new
clauses. Literals can be reused, and appeared in many different
clauses at once. 
\paragraph{hstring:}
This table is actually a linked list data structure representing
the sequence of hedge in a truth value. Each ``sequence'' has its id,
its ``head'' (a hedge id) and its ``tail'', which is a reference to
its subsequence. Many different sequences can share the same
subsequence.\\
Every literal has a reference to a hstring id, which is the ``hedge'' part
of its truth value.
\subsection{Use cases}

\begin{figure}[H]
\includegraphics[scale=0.85]{part2/UsecaseDiagram}
\caption{Use cases diagram of the system}
\end{figure}

\subsubsection{Use cases Overview}
\paragraph{} There are three main use cases:
\begin{itemize}
  \item {\bfseries Prove} concerns with using the system to prove
    a proposition w.r.t. to a KB. This use case extends to
    Explain use case,
    which concerns with explaining the proof.    
  \item {\bfseries Managing KB's hedges} concerns with using the
    system to managing the hedge algebra of a KB. This use case
    includes add/edit/remove use cases for each hedges list, for
    for positive and negative relations and print specification
    about the hedge algebra.
  \item {\bfseries Managing KB's clauses} concerns with using the
    system to managing the knowledge base. This use case includes
    add/remove/edit use cases for clauses, print KB, and check
    for KB's consistency usecases.    
\end{itemize}
\paragraph{} Each use case will be discussed in more detail in
the {\bfseries Execution Flow} section.
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=1]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=2]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=3]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=4]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=5]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=6]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=7]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=8]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=9]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=10]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=11]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=12]{part2/UCdesc}


\section{Architectural design}
\subsection{Modular Decomposition}
\begin{figure}[H]
\includegraphics[scale=0.78]{part2/_Modules}
\caption{Module dependency graph}
\end{figure}
\paragraph{}For reference purpose, below is the complete dependency
graph of the system, including the external libraries used.
\begin{figure}[H]
\includegraphics[width=450pt, height=600pt]{part2/Modules}
\caption{Complete dependency graph}
\end{figure}

\paragraph{} Reflecting the specification, the system is decomposed
into different groups of modules, each solving a relatively logically separated
concern:
\begin{itemize}
\item {\bfseries Hedge Algebra implementation concerns:} dealing with
  the implementation of this particular mathematical structure, and
  its runtime instantialization based on user's definition. This
  group consists of HedgeClass module and the modules in Hedgen:
  Hgen and Ahedge.
\item {\bfseries Linguistic Propositional Logic implementation concerns:} dealing
  with the implementation and representation of the aforementioned
  propositional logic. This group is dependent on the previous group's
  HedgeClass module. There are two modules in this group: HedgeTruth
  and ProsLogic.
\item {\bfseries Database interaction concerns:} dealing with
        database operations, which furtherly decomposed into:
        \begin{itemize}
          \item {\bfseries Hedge definition management concerns:}
                  dealing with the creation and management of
                  user-defined hedge algebra, which is one of the
                  main functionalities of the system. Hio is the
                  only module in this group. 
          \item {\bfseries KnowlegeBase management concerns:}
                  dealing with the creation and management of
                  knowledgebase, which is also one of the main
                  functionalities of the system. KBio is the only
                  module here.
        \end{itemize}
\item {\bfseries Automated reasoning concerns:} dealing with the
  reason-to-exist of the system: implementation of automated reasoning
  on linguistic logic using Alpha Resolution. This is the main
  functionalities of this system. The module in this system is,
  accordingly, AlphaResolution.
\end{itemize}
\subsubsection{Module HedgeClass}

\paragraph{}This module defines the Ha (short for Hedge algebra) typeclass, which is used as a basis for  actual hedge algebra. An instance Hedge of Ha (i.e. is the type for linguistic hedges) must define:

\begin{itemize}
\item A list of all linguistic hedges in the type Either a list of all
  positive hedges or a list of all negative hedges, or both list
\item  Either a positive relationship matrix, or a negative relationship
  matrix
\end{itemize}

\paragraph{}The Ha typeclass will accordingly generate:

\begin{itemize}
\item Operator <+> and <-> e.g. Very <+> Less = True means Very is
  positive w.r.t. Less, Less <-> Possibly = True means Less is
  negative w.r.t. 
\item Possibly Predicate positive and negative: Hedge ->
  Bool Comparing function compare': Hedge x Hedge -> LT | EQ | GT
\end{itemize}

\paragraph{}The HedgeClass module exports the typeclass Ha.

\subsubsection{Module HedgeTruth}


\paragraph{}This module defines the parametric type Truth. Given
a type Hedge that is an instance of Ha, this parametric type will
construct an actual linear symmetrical hedge algebra, with two
generators: Tru being the positive one, Fals being the negative
one. \\

\paragraph{}As an instance of the typeclass Ord, the compare
function for Truth is also defined in this module, and is used as
a basis for defining logical connectives for linguistic truth
value.\\

\paragraph{}This module depends on the HedgeClass module, exports the type Truth, and the following functions:

\begin{itemize}
\item isHTrue, isHFalse: test whether if a truth value has True or
  False tendency 
\item andH, orH, notH: and, or and not counterparts for
  linguistic truth value 
\item operator (><): test whether if two linguistic
  truth value has opposite tendency or not
\end{itemize}


\subsubsection{Module ProsLogic}

\paragraph{}The representations for literals and clauses of the propositional language are defined here. It exports the Lit and CNF types and their type accessors/constructors. This module depends on the two modules HedgeClass and HedgeTruth.


\subsubsection{Module AlphaResolution}

\paragraph{}The implementation of Alpha Resolution method and its auxiliary functions are defined in this module. This resolution function takes a set of clauses and performs Alpha Resolution on it. The returned value is of the type Maybe (Truth hedge), where it can be Nothing if the resolution didn't entail the null clause, or Just <truth value> if it did.\\

\paragraph{}This module depends on HedgeClass, HedgeTruth and ProsLogic modules and exports the resolution procedure.

\subsubsection{Component Hedgen}

\subparagraph{Module Hgen:} This module generate the declaration for the Hedge type
according to the description in the hedge database. Hedge will be an
instance of Ha, and this module will export this declaration.\\
To preserve type safety, Template Haskell requires that the declaration
generation and the actual declaration must be in two different
modules, so there must be another module to generate the actual Hedge type.\\
This module depends on the libraries Template Haskell, HDBC,
HDBC.SQLite3, the module Hio and using utilities from UtilB.\\
\subparagraph{Module Ahedge:} This is where the actual hedge type is
generated. This module just simply generates the type, and exports it
to the outside world.

\subsubsection{Component DBio:}
\subparagraph{Module Hio:} This module handles the operation on the
hedge definition tables in the database. It uses HDBC and
HDBC.Sqlite3, SelfRestart and module UtilB.
\subparagraph{Module KBio:} This module handles the operations on the
knowledge base DB. It depends on the libraries HDBC, HDBC.SQLite3 and UtilA, and exports the read, update and delete procedures.
\subsubsection{Component Util:}
\paragraph{} Because there are both some utility functions that are useful
both before and after the Hedge type is generated, and some other
utility functions that can only be meaningful after the generation of
that type, there are accordingly two utility providing modules: UtilB
for the former, and UtilA for the latter.
\subparagraph{Module UtilB:} This module provides some small utility
functions that don't depend on the presence of a Hedge type
\subparagraph{Module UtilA:} Likewise, but dependent on the presence of
type Hedge. It also reexport a bunch of other modules: Ahedge,
ProsLogic, AlphaResolution, Hio, SelfRestart and also UtilB itself.

\subsubsection{Module Main}

\paragraph{}This module is in charge of user interaction. The main
loop is defined here.
\section{System Implementation}

\subsection{Module HedgeClass}

\subsubsection{Import and Export:}

\begin{lstlisting}
module HedgeClass (
        Ha(..),
) where
import Data.List
\end{lstlisting}

\subsubsection{Description} Definition for the general LSHA mathematical
structures. Export Ha typeclass and all of its methods.
\subsubsection{Hedge typeclass}
\begin{lstlisting}
class (Eq a,Ord a,Enum a,Show a,Read a) => Ha a where
\end{lstlisting}

\paragraph{} A type class of linear symmetrical hedge algebras. This type
class captures the abstract algebraic structure of every LSHA,
but omits the positive and negative spanning terms and leaves
them to the logic definition to decide.\\

\emph{Properties:}
\begin{enumerate}
        \item h `elem` hedgeLs => h `elem` posLs OR h `elem` negLs
        \item h, k `elem` posLs/negLs => h >= k OR k >= h
        \item h, k `elem` hedgeLs => h <+> k OR h <-> k
\end{enumerate}
\paragraph{}
\emph{Methods}

\begin{enumerate}
        \item hedgeLs :: [a] - List of every hedge in the structure

        \item posLs :: [a]\\
        List of positive hedges

        \item negLs :: [a]\\
           List of negative hedges

        \item  positive :: Ha a => a -> Bool\\
           Test for the positivity of a hedge

        \item  negative :: Ha a => a -> Bool\\
          Test for the negativity of a hedge

        \item  allRel :: [(a, a)]\\
          Every relations in the structures. This list is used in the
          construction of the lists of positive and negative relations.
        \item  posRel :: [(a, a)]\\
          List of positive relations between hedges

        \item  negRel :: [(a, a)]\\
          List of negative relations between hedges

        \item  (<+>) :: a -> a -> Bool\\
          isPositive operation: h <+> k iff h is positive w.r.t k
        \item  (<->) :: a -> a -> Bool\\
          isNegative operation: h <-> k iff h is negative w.r.t k
        \item  compare' :: a -> a -> Ordering\\
          Generic comparing function for the structure. This is used in
          the Ord instance declaration of the structure
\end{enumerate}
Instances Ha Hedge defined in {\bfseries Ahedge}

\subsection{Module Hedgen.Hgen}
\subsubsection{Import and Export:}

\begin{lstlisting}
module Hedgen.Hgen  (
        q,
) where
import Language.Haskell.TH
import System.Console.Readline
import System.Environment
import Database.HDBC
import Database.HDBC.Sqlite3
import Util.UtilB
import DBio.Hio
import System.Directory(doesFileExist)
import Control.Monad
import Control.Exception
import SelfRestart(ExitCode(..),selfRestart,exitImmediately)
import Data.Char(toLower) 
\end{lstlisting}        
\subsubsection {Description} Generating a Hedge {\em declaration generator} from input knowledge
base's definition. The generator is exported to module Ahedge and
the Hedge is defined there.\\
This is also the first entry point of the program: while the sole
purpose is just to generate the declaration for Hedge, this
module will also take care of the case when the knowledge base is
not initialized, or there is no hedge definition in the knowledge
base.
\subsubsection{Hedge generator:}
\begin{lstlisting}
q :: Q [Dec]
\end{lstlisting}
The generator's type means that it is a {\em monadic} value of
an abstract syntax tree for a Haskell's declaration. This
abstract syntax tree will then be used to generate the
declaration code for the type Hedge.\\
The language extension TemplateHaskell makes this kind of metaprogramming
possible.
\subsubsection{Internal definition:}
\begin{itemize}
 \item hedgeDef :: [String] -> [String] -> [String] -> [[String]] ->
         [[String]] -> [Dec]\\
         This function takes the hedge definition's information
         extracted from the knowledge base and construct the
         abstract syntax tree of the declaration.

 \item cliGen :: FilePath -> IO [Dec]\\
         This IO function takes the path to the knowledge base
         and gets hedge definition from it, passes the
         definition to the aforementioned hedgeDef then returns
         the generated abstract syntax tree.\\
         It also performs initialization if the input knowledge
         base is a new file.
 \item startup :: IO [Dec]\\
         Wrapper around cliGen, to catch any unexpected
         exception. q will be created from this IO value.

 \item bulkQuery :: FilePath -> [String] -> IO [Integer]\\
       initSchema :: [String]\\
       Initialization for new knowledge base.
\end{itemize}

\subsection{Module Hedgen.Ahedge}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Hedgen.Ahedge (
        Hedge(..),
) where
import Hedgen.Hgen
import HedgeClass
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
\end{lstlisting}
\subsubsection{Description} Importing the generator q from Hgen and generating the
declaration for the type Hedge from q.\\
This module also defines the instance declaration of Ord
typeclass for Hedge using the Ha typeclass' method compare'. This
enables values of Hedge to use general comparing operation like <
or >= just like other Haskell's ordered types.
\subsubsection{Internal definition}
\begin{itemize}
        \item data Hedge = ... \\
                generated from Hgen.q\\\\
                {\bfseries Instances of: }
         \begin{itemize}
                 \item Enum Hedge 
                 \item Eq Hedge 
                 \item Ord Hedge
                 \item Read Hedge 
                 \item Show Hedge 
                 \item Ha Hedge
        \end{itemize}
        \item instance Ord Hedge where compare = compare'\\
                Ord instance definition for Hedge                
\end{itemize}

\subsection{Module HedgeTruth}
\subsubsection{Import and Export:}
\begin{lstlisting}
module HedgeTruth (
        Truth(..),
        isHTrue,
        isHFalse,
        andH,
        orH,
        notH,
        (><)) where
import
HedgeClass
import
Data.List
\end{lstlisting}
\subsubsection{Description}
This module defines the representation of linguistic truth
values, including the data type for truth value and some
operators on the data type.
\subsubsection{Internal Definition}
\begin{itemize}
\item data Truth hedge - The data type representing linguistic
        truth values.\\\\
        {\bfseries Constructors}
      \begin{itemize}
              \item Tru [hedge] - constructs from a list
                      [$h_1,h_2..h_n$] the value $h_1 h_2 ..
                h_n$ True
        \item Fals [hedge] - constructs from a list
                      [$h_1,h_2..h_n$] the value $h_1 h_2 ..
                h_n$ False 
        \item Maxt - representing the absolutely True value
        \item Mint - representing the absolutely False value
      \end{itemize}
        {\bfseries Instances of}
        \begin{itemize}
          \item Eq hedge => Eq (Truth hedge)
          \item Ha h => Ord (Truth h)
          \item Read hedge => Read (Truth hedge)
          \item Show h => Show (Truth h)
        \end{itemize}

\item isHTrue :: Truth h -> Bool\\
        Determine if a linguistic truth value is a positive term
        or not
\item isHFalse :: Truth h -> Bool\\
        Determine if a linguistic truth value is a positive term
        or not
\item andH :: Ha h => Truth h -> Truth h -> Truth h\\
        Linguistic logic And
\item orH :: Ha h => Truth h -> Truth h -> Truth h\\
        Linguistic logic Or
\item notH :: Ha h => Truth h -> Truth h\\
        Linguistic logic Not
\item (><) :: Ha h => Truth h -> Truth h -> Bool\\
        Test whether if two linguistic truth values are opposite or not
\end{itemize}

\subsection{Module ProsLogic}
\subsubsection{Import and Export:}
\begin{lstlisting}
module ProsLogic (
        Lit(..),
        CNF(..),
        truthLit,
        stringLit,
        lsCNF,
        smartCNF,
        sortCNF,
        sortLits,
        negateLit,
) where
import HedgeTruth
import HedgeClass
import Data.List
\end{lstlisting}
\subsubsection{Description}
This module defines the propositional fuzzy logic with truth
values being the type defined in module HedgeTruth. Also provides
some utilities to work with Literals and CNF clauses of this
logic.\\
As described below, several utilites are concerned with sorting
list of Literals. This is needed in order to easily test two
CNF clauses for equality. The sorting order is ascending based on
the String sentence in Literals, and if two String sentences are
equal, sort based on the truth value instead.\\
From here on out ``sorting list of Literals'' will by default
mean ``sorting list of Literals'' using the above order unless it
was explicitly said otherwise.
\subsubsection{Internal Definition}
\begin{itemize}
        \item data Lit hedge - A type representing Literals in this propositional fuzzy
                logic\\\\
         {\bfseries Constructors}
         \begin{itemize}
                 \item  Lit String (Truth hedge) - Construct a
                         Literal from a string being its sentence and a truth value 
         \end{itemize}
         {\bfseries Instances of}
          \begin{itemize}
            \item Eq hedge => Eq (Lit hedge)
            \item Read hedge => Read (Lit hedge) 
            \item Show hedge => Show (Lit hedge)
          \end{itemize}

         \item data CNF a - A disjunction of Literals\\\\
         {\bfseries Constructors}
         \begin{itemize}
          \item CNF [a] - Construct a disjunction of Literals
                  from a list of Literals.
         \end{itemize}
        {\bfseries Instances}
        \begin{itemize}
         \item Show a => Show (CNF a)
        \end{itemize}

\item truthLit :: Lit String (Truth t) -> Truth t\\
                Get the truth value of a Literal
        \item stringLit :: Lit String (Truth t) -> String\\
                Get the sentence of a Literal
        \item lsCNF :: CNF t -> [t]\\
                Convert the disjunction back to a list of
                Literals.
        \item negateLit :: Ha hedge => Lit hedge -> Lit hedge\\
                Negate the truth value of a Literal
        \item smartCNF :: Ha hedge => [Lit hedge] -> CNF (Lit
                hedge)\\
                Sorts the list of Literals before construct a
                disjunction.
        \item sortCNF :: Ha hedge => CNF (Lit hedge) -> CNF (Lit
                hedge)\\
                Sort the Literals in a disjunction.
        \item sortLits :: Ha hedge => [Lit hedge] -> [Lit
                hedge]\\
                Sort the Literals in a list of Literals.
\end{itemize}

\subsection{Module AlphaResolution}
\subsubsection{Import and Export:}
\begin{lstlisting}
module AlphaResolution (
        smartClause,
        confidence,
        resolvent',
        resolution,
        nilH,
        Clause(..)
) where
import Data.List
import HedgeClass
import HedgeTruth
import ProsLogic
import Debug.Trace
\end{lstlisting}
\subsubsection{Description}
Implementation of the $\alpha-Resolution$ reasoning method.
\subsubsection{Internal Definition}
\begin{itemize}
        \item type Clause hedge = ([Lit hedge], Truth hedge)\\
                This type represents the Clause with confidence
                described in the resolution section in
                Theoretical Background chapter.
        \item nilH :: Ha hedge => Lit hedge\\
                This is the Nil literal, which is in turn used to 
                represent the Nil clause.
        \item smartClause :: Ha hedge => CNF (Lit hedge) -> Truth hedge ->
                Clause hedge\\
                Construct a Clause from a disjunction and a
                confidence value. The list of Literals in
                the disjunction is sorted .
        \item confidence :: Ha h => Truth h -> Truth h -> Truth h -> Truth h ->
                Truth h\\
                Formula for calculating confidence value from two
                clauses' confidence values and their resolved
                Literals' truth values.

        \item resolution' :: Ha hedge => [Clause hedge] ->
        %[(Clause hedge, Clause hedge)] ->
        [(Clause hedge, Clause hedge, Clause hedge)] -> [(String, Maybe t)] -> (Maybe (Truth
        hedge), [(Clause hedge, Clause hedge, Clause hedge)])\\
        The actual implementation of the $\alpha-Resolution$
        reasoning method. It takes a list of Clause to perform
        resolution on, an accummulated argument for the tracing
        list, a list of all ``sentences'' in the knowledge base
        and whether interpretation of each sentences is a
        positive truth value or not. It returns the resulting
        confidence value of the resolution process and the
        tracing list.\\\\
        The tracing list has the type of [(Clause hedge, Clause
        hedge, Clause hedge)], with the first Clause in each
        tuple being the resolvent, and the other two Clauses
        being the resolved Clauses.\\\\
        The list of all ``sentences'' and their interpretation's
        positivity is needed to correctly reduce the new Clauses
        obtained in the process of $\alpha-Resolution$, as
        discussed in the Theoretical Background section. While
        computing this list might sound costly, without it the
        search space for $\alpha-Resolution$ will be much larger
        and ultimately the whole process wil cost much more.\\        
        This list obtained by performing a first-pass
        classical resolution on the knowledge base, i.e we
        consider the knowledge base as if it was in classical
        propositional logic and perform normal resolution on it.
        We only care about whether each sentence is ``True'' or
        not, so this is sufficient.    
        


        \item resolution :: Ha hedge => [Clause hedge] -> (Maybe
         (Truth hedge), [(Clause hedge, Clause hedge, Clause
         hedge)])\\
                The interfacial method for using
                $\alpha-Resolution$. It takes a list of Clause
                and returns the confidence value of the
                resolution, and the tracing list to reconstruct
                the proof if needed.\\
                It is a wrapper around the
                actual implementation resolution', initializing
                some arguments of resolution' with appropriate
                values. 
\end{itemize}

\subsection{Module Hio}
\subsubsection{Import and Export:}
\begin{lstlisting}
module DBio.Hio(
  hManager,
  ) where
import SelfRestart
import Util.UtilB
import Database.HDBC
import Database.HDBC.Sqlite3
import Control.Monad
import Data.Char
import SelfRestart(selfRestart,exitImmediately,ExitCode(..))
import System.Environment(getProgName)
\end{lstlisting}
\subsubsection{Description}
This module defines the procedures to work with the hedges
definition in the knowledge base. 
\subsubsection{Internal Definition}
\begin{itemize}
        \item printlH :: IConnection conn => String -> conn -> IO
                ()\\ Generic hedges list print
              \begin{itemize}
               \item printPosH :: IConnection conn => conn -> IO ()\\
                     printNegH :: IConnection conn => conn -> IO ()\\
                     Specialized printing procedures for positive
                     and negative hedges lists.
              \end{itemize}         
             
      \item removeH :: String -> String -> IO ()\\
              Completely remove a hedge from the database
      \item removelH :: String -> String -> String -> IO ()
              Generic ``remove'' procedure to remove a hedge from
              a list
              \begin{itemize}
               \item removePosH :: String -> String -> IO ()
                     \\removeNegH :: String -> String -> IO ()\\
                     Specialized remove procedures for positive
                     and negative hedges lists
              \end{itemize}

      \item addlH :: String -> String -> String -> String -> String -> IO ()
            \\ Generic ``add new hedge'' procedure  
      \begin{itemize}
      \item addNegH :: String -> String -> String -> String -> IO ()
          \\addPosH :: String -> String -> String -> String -> IO ()
          \\ Specialized add procedures for positive
            and negative hedges lists
      \end{itemize}

      \item changeOrd :: String -> String -> String -> String -> IO ()
              \\Generic ``change order of hedges'' procedure
      \begin{itemize}
      \item changePosOrd :: String -> String -> String -> IO ()
         \\ changeNegOrd :: String -> String -> String -> IO ()
         \\ Specialized change order procedures for positive and negative
         hedges lists.
      \end{itemize}

      \item renameHedge :: String -> String -> String -> IO ()
       \\ rename a hedge in the database

      \item addlRel :: String -> String -> String -> String -> IO ()
              \\ Generic ``add new relation between hedges''
              procedure
      \begin{itemize}
      \item addPosRel :: String -> String -> String -> IO ()
          \\ addNegRel :: String -> String -> String -> IO ()
         \\ Specialized add relation procedures for positive and negative
         hedge relations lists.
      \end{itemize}

      \item removelRel :: String -> String -> String -> String -> IO ()
              \\ Generic ``remove a relation between hedges''
              procedure
      \begin{itemize}
      \item removePosRel :: String -> String -> String -> IO ()
        \\  removeNegRel :: String -> String -> String -> IO ()
         \\ Specialized remove relation procedures for positive and negative
         hedge relations lists.
      \end{itemize}

      \item hManager :: String -> IO ()\\
              \\ The interactive interface for managing hedges.
              This is the only exported procedure in this module,
              and the functionalities of other procedures can
              only be accessed through this procedure.
      \item printHedges :: String -> IO ()\\
              Print the hedge structure as currently defined in the
              knowledge base.
\end{itemize}
\subsection{Module KBio}
\subsubsection{Import and Export:}
\begin{lstlisting}
module DBio.KBio (
        cmenu,
        kbManager,
        parseGoals,
        getCNF) where
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution
import Util.UtilA
\end{lstlisting}
\subsubsection{Description}
This module provides the procedures to work with the knowledge
base's clauses, which internally have to process other entities
in the database that are hidden to the end user e.g. literals, hedge
strings, literals-clauses relationship.
\subsubsection{Internal Definition}
\begin{itemize}
        \item sid\_to\_hstring :: FilePath -> SqlValue -> IO
                [String]\\
                Transform a database's SID into its equivalent
                sequence of hedge name. This is used by the reasoning
                system to regenerate the truth value of a
                literal.                
        \item hStringtoHid :: String -> [String] -> IO (Maybe
                [SqlValue])\\
                Transform a sequence of hedge names to the equivalent
                list of database's HID, which is in turn used by find\_sid to
                recreate SID from a sequence of hedge names.
        \item find\_sid :: IConnection conn => conn -> ([SqlValue], SqlValue,
                 [SqlValue]) -> IO ([SqlValue], SqlValue,
                 [SqlValue])\\
                 Find the equivalent SID of a sequence of HID.
        \item insert\_if\_not\_exist\_sid :: String -> [Char] -> IO (Maybe
                 SqlValue)\\
                 Insert a SID for a string of hedges, if that
                 hasn't existed yet. Return the inserted SID or
                 Nothing.
        \item getCid :: String -> IO [String]\\
                Get a list of all CIDs in the database. This is
                used by getCNF to retrieve the list of all
                clauses in the database.
        \item getCNF :: String -> IO [CNF (Lit Hedge)]\\
                Retrieve the list of all clauses in the database
        \item parseGoal :: String -> Lit Hedge\\
                Parse a string into a Literal.
        \item parseGoals :: String -> [Lit Hedge]\\
                Apply parseGoal on a string of literals'
                representations, and parse it into a list of
                Literals.
        \item parseInpClause :: String -> [[String]]\\
                Break an input clause into a list of
                representations for its literals, each literal
                in turn is splitted into its sentence/symbol, its
                hedges string and its truth generating term.
        \item changeByCID :: String -> String -> String -> IO
                ()\\
                Change a clause by its CID.
        \item changeClause :: String -> [Char] -> String -> IO
                ()\\
                Change a clause by its formula. Internally use
                changeByCid
        \item deleteByCID :: String -> String -> IO ()\\
                Delete a clause by its CID
        \item deleteClause :: String -> [Char] -> IO ()\\
                Delete a clause by its formula. Internally use
                deleteByCID.
        \item addClause :: String -> [Char] -> IO ()\\
                Add a new clause by its formula
        \item kbManager :: String -> IO ()\\
                Interactive loop for knowledge base management
                use case
        \item cmenu :: [String] \\
                Menu for kbManager

\end{itemize}
\subsection{Module UtilA}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Util.UtilA (
    okTruthStr,
    toClause,
    printClauses,
    printLits,
    prove,
    printHedges,    
    nil,
    headIs,
    findHead,
    retrace,
    module SelfRestart,
    module Util.UtilB, 
    module DBio.Hio
  ) where
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution

import Data.IORef
import Data.List.Split
import Data.Char

import Database.HDBC
import Database.HDBC.Sqlite3

import System.Environment
import System.Console.Readline

import Control.Concurrent
import Control.Monad
import Util.UtilB
import DBio.Hio
import SelfRestart (selfRestart,
forkSelfRestartExePollWithAction, exitImmediately, ExitCode(..))

\end{lstlisting}
\subsubsection{Description}
This module defines some commonly used small utilities that don't
really fit anywhere else. Only valid {\em after} Hedge is
defined. It also reexports a bunch of other modules for
convenience.
\subsubsection{Internal Definition}
\begin{itemize}
        \item okTruthStr :: [Char] -> Bool\\
         Check if a truth string is in proper format or not
        \item toClause :: Ha hedge => [CNF (Lit hedge)] ->
                [Clause hedge]\\
              Transform a CNF clause into a Clause.  
        \item printClauses :: Show a => [([a], t)] -> IO ()\\
                print a set of Clauses
%        \item printLits :: Ha hedge => [CNF (Lit hedge)] -> IO ()
        \item prove :: Ha hedge => [CNF (Lit hedge)] -> CNF (Lit hedge) ->
           (Maybe (Truth hedge), [(Clause hedge, Clause hedge, Clause hedge)])\\
            Wrapper around the alphaResolution function, it takes
            a knowledge base and a CNF clause, then return a pair
            consists of a Maybe value of confidence value, and a
            tracing list that can be used to recreate the proof.          
        \item printHedges :: FilePath -> IO ()\\
                print the hedges structure currently using in
                parallel with the one defined in the knowledge base. The FilePath
                parameter is meant for the path to the database
                file.
        \item nil :: [Lit Hedge]
                the nil Clause.
%        \item headIs :: Eq a => a -> (a, t, t1) -> Bool
%        \item findHead :: Eq a => a -> [(a, t, t1)] -> Maybe (a, t, t1)
        \item retrace :: (Eq t, Show t) => t -> [(t, t, t)] -> [t] -> [Char]
                recreate the proof from the trace.
\end{itemize}
\subsection{Module UtilB}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Util.UtilB (
    properFormat,
    properTruthString,
    fromQuery,
    readline'
  ) where
import Data.IORef
import Data.List.Split
import Data.Char

import Database.HDBC
import Database.HDBC.Sqlite3

import System.Environment
import System.Console.Readline

import Control.Concurrent
import Control.Monad
\end{lstlisting}
\subsubsection{Description}
This module defines some commonly used small utilities that don't
fit anywhere else. Always available.
\subsubsection{Internal Definition}
\begin{itemize}
\item properFormat :: String -> String\\
        Transform a single word to proper format
\item properTruthString :: String -> [String]\\
        Transform a sentence into a list of properly formatted
        words.
\item fromQuery :: [[SqlValue]] -> [[String]]\\
        Convert the SqlValue results of SQL queries into Haskell
        value.
\item readline' :: IO String\\
        A wrapper for the library function readline. Used
        for getting interactive input in place of readline.
\end{itemize}
\subsection{Module Main}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Main where
import Util.UtilA
import Util.UtilB
import DBio.KBio
import DBio.Hio
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution
import Control.Exception
\end{lstlisting}
\subsubsection{Description}
This module simply defines the main IO loop to interact with the
user.
%\subsubsection{Internal Definition}


\section{Execution flow}
\paragraph{} This section illustrates the execution of the
system, structured by the flow of use cases. Each subsection will describe the 
flow a use case of the system. 
%-----------------------------------------------%
\subsection{Invoke Reasoning System}
\begin{itemize}
  \item {\bfseries Description:} This is the start-up use case.
    The goal is to get the reasoning system up-and-running, with a
    user-specified knowledge base loaded.   
  \item {\bfseries Trigger:} The user invoke {\em runhaskell
    Main.hs <dbname>} in the system's directory

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/openKB1}
  \caption{Illustration: invoking the reasoning system}
\end{figure}

  \item {\bfseries Precondition:} The reasoning system is present and its
    dependencies are all installed.    
  \item {\bfseries Postcondition:} The reasoning system is
    up-and-running, with a knowledge base loaded.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item Start the reasoning system
      \item Load the knowledge base
      \item Generate Hedge algebra to use as defined in the
        knowledge base
      \item Enter main interactive loop, wait for user's
        command\\
        \indent + Trigger use case according to user's command
        \indent + Terminate the system if user chooses to do so
    \end{enumerate}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/mainloop}
  \caption{Illustration: The main interactive loop of reasoning system}
\end{figure}
  \item {\bfseries Alternative Flow:}
    \\{\em No hedge algebra defined in KB}
    \begin{enumerate}
      \item Ask if the user wants to define hedge algebra\\
            \indent + If yes, trigger KB's hedge managing use
            case 
            Base\\
            \indent + Otherwise, terminate the system
    \end{enumerate}
    {\em No hedge algebra defined in KB}
      \item Ask if the user wants to initialize new KB\\
          \indent + If yes, trigger Initialize new KB use case\\
          \indent + Otherwise, terminate the system

  \item {\bfseries Exception Flow:}\\
    {\em Empty Argument}
    \begin{enumerate}
      \item Inform the user
      \item Terminate the system
    \end{enumerate}

    {\em Database Error}
    \begin{enumerate}
      \item Inform the user\\
        \indent + If the user chooses to go to main menu anyway,
          continue anyway
        \indent + Otherwise, terminate the system      
    \end{enumerate}

\end{itemize}

%---%
\subsubsection{Extended use case: Initialize new Knowledge Base}
\begin{itemize}
  \item {\bfseries Description:} This use case's goal is to
    initialize a new knowledge base.
  \item {\bfseries Trigger:} The KB file the user specified is a
    new file.
  \item {\bfseries Precondition:} \\
    \indent + Invoke Reasoning System is triggered\\
    \indent + The specified KB file is a new file
  \item {\bfseries Postcondition:} KB initialized to the proper
    schema    
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item Create tables as specified by the system's database
        schema
      \item Create the required triggers as specified in the
        schema
      \item Ask if the user wants to define a hedge algebra for
        the KB right now\\
        \indent + If yes, trigger KB's hedge managing use case\\
        \indent + Otherwise, go back to the call site
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:} {\em No exception flow}
\end{itemize}

%-----------------------------------------------%
\subsection{Manage KB's clauses}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/kb-manager}
  \caption{Illustration: Manage KB's clauses interactive loop}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} This use case consists of a set
    of standard database management functionalities, 
    including add/remove/edit/view operations. Since this system
    works with knowledge base, logical consistency is vital,
    so additionally there is also a Check consistency use case
    for this purpose.\\
    The Hedge structure use case is not
    important and will not be discussed here, but it is useful for 
    quick reference of the underlying
    hedge algebra when working with clauses. This is however a
    little bit different from the Print HA structure use case extending
    Managing KB's hedges use case, since the latter only print
    the hedge algebra as defined in the knowledge base, while the
    former also concerns with the hedge algebra as being used by
    the reasoning system. These two definition could have mismatch
    at runtime if the maintainer after updated the hedge algebra
    definition somehow still decided to keep on using the old
    definition for the session.
  \item {\bfseries Trigger:} User choose ``kb manager'' from the
    main loop
  \item {\bfseries Precondition:} The system is up and running
    with a knowledge base loaded    
  \item {\bfseries Postcondition:} Zero or more knowledge base management
    actions with persistent effect on the knowledge base performed
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User trigger the use case
      \item Waiting for user's command\\
      \indent + Trigger an extended use case base according to
      user's command\\
      \indent + Go back to main loop if user chooses to do so
      \item Go back to 1
    \end{enumerate}
  \item {\bfseries Alternative Flow:}\\
    {\em Unrecognized command}\\
    \indent + Inform the user\\
    \indent + Back to wait for user's command
  \item {\bfseries Exception Flow:} {\em No Exception Flow}
\end{itemize}
%-----------------------------------------%
\subsubsection{Extended use case: Add clause}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/add-clause}
  \caption{Illustration: Add clause use case}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} Add a new clause into the
    knowledge base. The clause must be a disjunction of literals.
  \item {\bfseries Trigger:} User chose ``add clause'' command in
    Manage KB's clauses use case
  \item {\bfseries Precondition:} Manage KB's clauses triggered.
  \item {\bfseries Postcondition:} A new clause added unless it
    was already in the knowledge base, or it was not valid    
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Add clause
      \item The system asks user for the clause\\
        \indent + If the clause is in the KB already, inform the
        user and do nothing   \\
        \indent + Otherwise, add the clause to the KB        
    \end{enumerate}
  \item {\bfseries Alternative Flow:}
    {\em Clause is not in proper format}
    \begin{enumerate}
      \item Inform the user
      \item Back to parent use case
    \end{enumerate}
    {\em Clause has unrecognized linguistic truth value}
    \begin{enumerate}
      \item Inform the user
      \item Back to parent use case
    \end{enumerate}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}
%--------------%
\subsubsection{Extended use case: Remove clause}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/rm-clause}
  \caption{Illustration: Remove clause use case}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} Specify a clause and remove it from the
    knowledge base. The input clause must be a disjunction of literals.
  \item {\bfseries Trigger:} User chose ``rm clause'' command in
    Manage KB's clauses use case
  \item {\bfseries Precondition:} Manage KB's clauses triggered.
  \item {\bfseries Postcondition:} A clause removed unless it
    was already not the knowledge base, or the input is invalid   
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Remove clause
      \item The system asks user for the clause\\
        \indent + If the clause is not the KB, inform the
        user and do nothing   \\
        \indent + Otherwise, remove the clause from the KB        
    \end{enumerate}
  \item {\bfseries Alternative Flow:}
    {\em Clause is not in proper format}
    \begin{enumerate}
      \item Inform the user
      \item Back to parent use case
    \end{enumerate}
    {\em Clause has unrecognized linguistic truth value}
    \begin{enumerate}
      \item Inform the user
      \item Back to parent use case
    \end{enumerate}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}
\subsubsection{Extended use case: Edit clause}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/change-clause}
  \caption{Illustration: Edit Clause use case}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} Edit a clause in the
    knowledge base. The modified clause must be a disjunction of literals.
  \item {\bfseries Trigger:} User chose ``change clause'' command in
    Manage KB's clauses use case
  \item {\bfseries Precondition:} Manage KB's clauses triggered.
  \item {\bfseries Postcondition:} A clause is edited unless it
    was already not the knowledge base, or the input was not
    valid
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Edit clause
      \item The system asks user for the old clause\\
      \item The system asks user for the modified clause\\
        \indent + If the clause is not in the KB, inform the
        user and do nothing   \\
        \indent + If the new clause is in the KB, inform the user
        and do nothing\\
        \indent + Otherwise, modify the clause to the new clause        
    \end{enumerate}
  \item {\bfseries Alternative Flow:}
    {\em Clause is not in proper format}
    \begin{enumerate}
      \item Inform the user
      \item Back to parent use case
    \end{enumerate}
    {\em Clause has unrecognized linguistic truth value}
    \begin{enumerate}
      \item Inform the user
      \item Back to parent use case
    \end{enumerate}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

\subsubsection{Extended use case: Check consistency}
\begin{itemize}
  \item {\bfseries Description:} Checking for the logical
    consistency of the knowledge base, and report to the user.
  \item {\bfseries Trigger:} User chose ``check'' command in
    Manage KB's Clause use case
  \item {\bfseries Precondition:} Manage KB's clauses triggered.    
  \item {\bfseries Postcondition:} The KB is checked, and its
    consistency status is reported.

  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Check consistency
      \item The system perform $\alpha-Resolution$ on the KB to
        investigate its consistency status
      \item Report the consistency status of the KB  
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No Alternative Flow}
  \item {\bfseries Exception Flow:} 
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}
\subsubsection{Extended use case: Print KB}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/printkb}
  \caption{Illustration: Print KB use case}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} Let the user view the knowledge
    base
  \item {\bfseries Trigger:} User chose ``print KB'' in the
    Manage KB's Clause use case
  \item {\bfseries Precondition:} Manage KB's clauses triggered.    
  \item {\bfseries Postcondition:} KB is printed.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Print KB
      \item The system print the KB
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No Alternative Flow}
  \item {\bfseries Exception Flow:} 
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

%-----------------------------------------------%
\subsection{Manage KB's hedges}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/hedge-manager}
  \caption{Illustration: Manage KB's clauses interactive loop}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} This use case consists of a set
    of operations to define and maintain the hedge algebra
    underlying the knowledge base.
  \item {\bfseries Trigger:} User chose ``hedge manager'' in the
    main interactive loop
  \item {\bfseries Precondition:} The system is up and running
    with a knowledge base loaded    
  \item {\bfseries Postcondition:} Zero or more hedges management
    actions with persistent effect on the knowledge base performed
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User trigger the use case
      \item Waiting for user's command\\
      \indent + Trigger an extended use case base according to
      user's command\\
      \indent + Go back to the call site and do not reload the
      updated hedge definition for the executing system yet if
      the user chose ``quit''
      \indent + reload the updated hedge definition for the executing system and 
      go back if the user chose ``reload''
      
      \item Go back to 1
    \end{enumerate}
  \item {\bfseries Alternative Flow:}\\
    {\em Unrecognized command}\\
    \indent + Inform the user\\
    \indent + Back to wait for user's command
  \item {\bfseries Exception Flow:} {\em No Exception Flow}
\end{itemize}
\subsubsection{Extended use case: Print HA structure}
\begin{itemize}
  \item {\bfseries Description:} Let the user view the knowledge
    base's hedge algebra structure
  \item {\bfseries Trigger:} User chose ``print'' in the
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.    
  \item {\bfseries Postcondition:} KB's hedge algebra structure is printed.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Print HA structure
      \item The system print the structure
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No Alternative Flow}
  \item {\bfseries Exception Flow:} 
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

\subsubsection{Extended use case: Add positive/negative hedge}
\begin{itemize}
  \item {\bfseries Description:} Add a hedge into the
    positive/negative list. The hedge may or may not already
    exist.
  \item {\bfseries Trigger:} User chose ``add positive'' or
    ``add negative'' command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:}\\
    \indent + The hedge is added to the KB if it was not already
    added.
    \indent + The hedge is added to the list unless it
    was already in the list
    \indent + The hedge is moved from the other list to this list
    if it was already in the other list
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Add positive/negative hedge 
      \item The system asks user for the hedge\\
        \indent + If the hedge is in the list already, inform the
        user and do nothing   \\
        \indent + If the hedge is not in the KB, add the hedge to
        the KB, then add it to the list
        \indent + If the hedge is in the other list, move it to
        this list
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

\subsubsection{Extended use case: Remove positive/negative hedge}
\begin{itemize}
  \item {\bfseries Description:} Remove a hedge from the
    positive/negative list. 
  \item {\bfseries Trigger:} User chose ``rm positive'' or
    ``rm negative'' command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:} The hedge is removed from the
    list if it was there, or nothing happens.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose rm positive/negative hedge 
      \item The system asks user for the hedge\\
        \indent + If the hedge is in the list, remove it 
        \indent + Otherwise, do nothing.
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

\subsubsection{Extended use case: Edit positive/negative hedge's precedence}
\begin{itemize}
  \item {\bfseries Description:} Edit the order of hedges precedence in the
    positive/negative list. 
  \item {\bfseries Trigger:} User chose ``mv positive'' or
    ``mv negative'' command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:} The chosen hedge's position in
    the list changed. Other hedges' precedences are also changed
    accordingly in respect with the new order.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Edit positive/negative hedge's precedence
      \item The system asks user for the hedge\\
        \indent + If the hedge is in the list\\
        \indent\indent + move it to the new position accordingly
        to its new precedence
        \indent\indent + the database's triggers are activated to
        take care of maintaining the order
        \indent + Otherwise, do nothing.
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

\subsubsection{Extended use case: Rename hedge}
\begin{itemize}
  \item {\bfseries Description:} Edit the name of the hedge in the
    knowledge base. 
  \item {\bfseries Trigger:} User chose ``rename hedge'' command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:} The chosen hedge's name is
    changed unless its new name has already existed, or the hedge
    itself is not in the knowledge base.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Rename hedge
      \item The system asks user for the hedge and its new name\\
        \indent + If the hedge is in the list, and the new name
        is not occupied, rename it to the new name      
        \indent + Otherwise, do nothing.
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}

\subsubsection{Extended use case: Add positive/negative hedges relation}
\begin{itemize}
  \item {\bfseries Description:} Add a positive/negative relation
    between two hedges into the
    positive/negative relation list. 
  \item {\bfseries Trigger:} User chose ``add positive relation'' or
    ``add negative relation'' command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:}\\
    \indent + The relation is added to the list, and the other
    list will be recalculated to maintain consistency.    
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Add positive/negative relation 
      \item The system asks user for the two hedge\\
        \indent + If at least one of the hedges is not in either
        positive or negative list, inform the
        user and do nothing
        \indent + Otherwise, add the relation to the respective
        relation list, and recalculate the other list to maintain
        consistency
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}


\subsubsection{Extended use case: Remove positive/negative hedges relation}
\begin{itemize}
  \item {\bfseries Description:} Remove a positive/negative relation
    between two hedges into the
    positive/negative relation list. 
  \item {\bfseries Trigger:} User chose ``rm positive relation'' or
    ``rm negative relation'' command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:}\\
    \indent + If the relation is in the list, it will be removed from the list, and the other
    list will be recalculated to maintain consistency.    
    \indent + Otherwise, nothing happens
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Remove positive/negative relation 
      \item The system asks user for the two hedges\\
        \indent + If at least one of the hedges is not in either
        positive or negative list, inform the
        user and do nothing
        \indent + If the relation is not in the list, inform the
        user and do nothing
        \indent + Otherwise, remove the relation from the respective
        relation list, and recalculate the other list to maintain
        consistency
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}


\subsubsection{Extended use case: Remove hedge}
\begin{itemize}
  \item {\bfseries Description:} Remove a hedge from the
    knowledge base. 
  \item {\bfseries Trigger:} User chose ``rm hedge''
    command command in
    Manage KB's hedges use case
  \item {\bfseries Precondition:} Manage KB's hedges triggered.
  \item {\bfseries Postcondition:} The hedge and all of its
    related information are removed from the
    knowledge base if it was there, or nothing happens.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Remove hedge 
      \item The system asks user for the hedge\\
        \indent + If the hedge is in the knowledge base\\
        \indent\indent + Trigger Remove positive relation use
        case\\
        \indent\indent + Trigger Remove negative relation use
        case\\
        \indent\indent + Trigger Remove positive hedge use
        case\\
        \indent\indent + Trigger Remove negative hedge use
        case\\
        \indent + Otherwise, do nothing.
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No alternative flow}
  \item {\bfseries Exception Flow:}
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}



%-----------------------------------------------%
\subsection{Prove proposition}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/unprovable}
  \caption{Illustration: Prove proposition: unprovable case}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/provable}
  \caption{Illustration: Prove proposition: provable case}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} Let the user query for the
    confidence of a proposition. The proposition must be a
    conjunction of literals.   
  \item {\bfseries Trigger:} User chose ``prove'' from the main
    interactive loop
  \item {\bfseries Precondition:} The reasoning system is up and
    running with a knowledge base loaded.
    
  \item {\bfseries Postcondition:} A confidence value is printed
    if the proposition is valid, or ``Nothing'' is printed if the
    it is not provable (not necessarily false)

  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Prove proposition
      \item The system asks for a proposition to prove\\
      \indent + If the proposition is not valid, inform the user
      and go back to main loop
      \indent + Otherwise, ask if the user wants the system to
      explain the result or not
      \indent\indent + Use $\alpha-Resolution$ on the KB and the
      proposition
      \indent\indent + Print the confidence value if the
      proposition is provable, or ``Nothing'' otherwise.
    \item Go back to main interactive loop if the user did not
      choose to get an explaination
    \end{enumerate}
  \item {\bfseries Alternative Flow:}\\
    {\em User chose to have an explaination of the result}
    \begin{enumerate}
      \item Trigger the Explain use case
      \item Go back to main interactive loop after the
        explaination is done
    \end{enumerate}
  \item {\bfseries Exception Flow:} 
    {\em Database Error}
    \begin{enumerate}
      \item Inform the user
      \item Ask if the user wants to go back to main loop anyway,
        or just exit\\
        \indent + Go back to main loop if the user chooses to do
        so\\
        \indent + Otherwise, terminate execution
    \end{enumerate}
\end{itemize}
\subsubsection{Extended use case: Explain proof result}
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/explain}
  \caption{Illustration: Explaination of the previous provable
  Illustration}
\end{figure}
\begin{itemize}
  \item {\bfseries Description:} Explain the result of the
    $\alpha-Resolution$ in the Prove use case
  \item {\bfseries Trigger:} User chose to get an explaination
  \item {\bfseries Precondition:}\\
    \indent + Prove use case triggered
    \indent + Successfully performed $\alpha-Resolution$ in the
    Prove use case    
    \indent + The result of $\alpha-Resolution$ is not
    ``Nothing''
  \item {\bfseries Postcondition:} The explaination of how the
    system got to that result is printed
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item Get the trace returned by the proving
        procedure        
      \item Reconstruct the proof tree from the trace
      \item Print the tree
      \item Go back to the main interactive loop  
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No Alternative Flow}
  \item {\bfseries Exception Flow:} {\em No Exception Flow}
\end{itemize}
%-----------------------------------------------%
\subsection{Exit}
\begin{itemize}
  \item {\bfseries Description:} Terminate the execution of the
    system
  \item {\bfseries Trigger:} User chose ``quit'' command from the
    main interactive loop
  \item {\bfseries Precondition:} The reasoning system is up and
    running    
  \item {\bfseries Postcondition:} The reasoning system's
    execution is terminated.
  \item {\bfseries Normal Flow:}
    \begin{enumerate}
      \item User chose Exit
      \item The system terminates.
    \end{enumerate}
  \item {\bfseries Alternative Flow:} {\em No Alternative Flow}
  \item {\bfseries Exception Flow:} {\em No Exception Flow}
\end{itemize}
\section{Sample result}
\paragraph{} As a final touch, this section will consider a
simple example to illustrate the $\alpha-Resolution$ inference
method as implemented in this reasoning system. The knowledge
base and the queried proposition are chosen so that there are
more than one way to prove the proposition with resolution, and
the confidence value of each proof will be different. 
\paragraph{} Consider the knowledge base as illustrated below:
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/printkb}
  \caption{Example knowledge base}
\end{figure}
\paragraph{} The LSHA as the truth domain used to defined the
above knowledge base is $AX = \{X, G = {c^{+} = True, c^{-} =
False}, H = \{More, Very, Possibly, Less\}, \le\}$ \\ where $H^{+} =
\{More, Very\}, More \le Very$, $H^{-} = \{Possibly, Less\},
Possibly \le Less$ and the relation matrix is as follow:
\begin{table}[H]
  \centering
\begin{tabular}{|l|c|c|c|c|}
\hline
            Affecting$\backslash$Affected & More & Very & Possibly & Less \\ \hline
            More                        & +    & +    & -    & -    \\ \hline
            Very                        & +    & +    & -    & +    \\ \hline
            Possibly                    & -    & -    & -    & -    \\ \hline
            Less                        & -    & -    & -    & -    \\ \hline
\end{tabular}
\caption {A hedges relation matrix}
\end{table}
\paragraph{} The {\bfseries Goal} we want to prove here is:\\ G = 
\(\text{``Spratly Islands is Vietnam's undisputable
territory''}^{\text{Very More True}}\). To prove G, we will
perform resolution on $S = KB \cup \neg{G}$. In the beginning, every
clause in S will be given maximum confidence value.
\paragraph{} At the first glance, the easiest resolution proof
would be this one:
\begin{enumerate}
  \item (G, Maxt)\\
    `resolvedWith`\\
    (``China's territorial claims have always been
    controversial''$^{\text{Less False}}$ OR ``Spratly Islands is Vietname's
    undisputable territory''$^{\text{Possibly True}}$, Maxt)\\
    \indent  => (``China's territorial claims have always been
    controversial''$^{\text{Less False}}$, Possibly True) (1)
  \item (1)\\
    `resolvedWith`\\
    (``China's territorial claims have always been
    controversial''$^{\text{Very False}}$ )\\
    \indent => (NULL, Less True)
\end{enumerate}
\paragraph{} So the confidence of this proof is Less True. However let's
consider the $\alpha-Resolution$ proof of the system:
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/explain}
  \caption{$\alpha-Resolution$ proof for the example}
\end{figure}
\end{document}
\paragraph{} The confidence for this proof is More True, which is
obviously better than Less True. And in fact as discussed in the
Theoretical Background chapter, $\alpha-Resolution$ always
derives the proof with the highest confidence.
