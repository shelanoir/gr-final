\documentclass[../gr-final.tex]{subfiles}
\begin{document}
\lstset{language=Haskell}
%\subfile{chap1}
\part{Results}
\chapter{System Implementation}

\paragraph{} The system in this report is a reasoning system using a
propositional logic with user-defined linear symmetrical hedge algebra
as the domain of truth value. The reasoning method to be used is the
aforementioned Alpha Resolution in the previous part.
	
\paragraph{} The main objective of implementing this system is to demonstrate the applicability and feasibility of automated linguistic logic reasoning systems based on linear symmetrical hedge algebra, to design and implement a system for developing knowledge bases capable of capturing fuzzy linguistic 
concepts, using user-defined LSHA-based truth value domain, as an alternative to traditional fuzzy logic knowledge base.



\section{Problem Definition}

\paragraph{}Essentially, the problem to be solved by this system is,
with a user-defined linear symmetrical hedge algebra (LSHA) as a truth value
domain, a knowledgebase in the form of hedge algebra based
propositional CNF  clauses, if a user had a proposition of the form
\(A^{truth-value}\), the system should be able to tell if this
proposition is true or not, and with as much confidence as it could guarantee.\\
In addition, the system must also provide the
functionality to create, update and manage knowledgebase and
hedge algebra definition. 

\paragraph{}The input of the program is a database describing the hedge algebra to be used, and another database where the knowledge base is stored.\\
The hedge definition including the tables below:
\begin{itemize}
\item A table defining the hedges of the LSHA, containing each hedge's
  unique name and id.
\item Two tables for the positive/negative hedges, and their precedence/ranking.
\item Two tables defining the positive and negative relationships 
  between hedges.
\end{itemize}

\paragraph{}The generator terms of the hedge algebras are always True
and False, so they don't need to be specified in the truth domain's
definition. There are also two other truth constant: Maxt for the
maximum truth value, and Mint for the minimum truth value, regardless
of the set of hedges.\\ 

\paragraph{}The knowledgebase database including:

\begin{itemize}
\item A table describing disjunctive clauses, including their id and
  optionally their label. 
\item A table of literals used in the KB's clauses, with their id,
  name, and two columns to determine their truth value supscribe: sid
  is a reference to the table of sequences of hedges, and seed is one
  of the four generator terms: True, False, Maxt or Mint.
\item A table describing sequences of hedges, including their id,
  their ``head'' hedge's id, and their ``tail'' sequences of hedges
  id, which is a reference to this table itself. 
\item A table relating clauses with the literals they use, with two
  columns being reference to clauses table and literals table, respectively
\end{itemize}

\paragraph{} The Output is either a linguistic truth value, which is
the confidence of the resolution process on the queried clause, or
literally a Nothing value if that clause were unprovable.

\section{High level Requirements}
\subsection{Functional Requirements}
\begin{itemize}
\item Enable user defined hedge algebra structure, and allow user to
  manage the definition of said structure.
\item Enforcing hedge algebra laws on the user defined hedges
\item Allow user to use, create and manage fuzzy knowledgebase
\item Able to answer user's query by proving it
\end{itemize}

\subsection{Non- Functional Requirements}
\begin{itemize}
\item Acceptable performance
\item Easy to use
\end{itemize}

\subsection{Quality Attributes}

\paragraph{Correctness:}
The reasoning process must be {\em sound} and {\em complete}.

\paragraph{Maintainability:}
The system should be easy to maintain and extend

\section{System configuration}

\paragraph{}The programming language being used is Haskell, a purely functional programming language. The particular implementation of Haskell used for this system is the Glasgow  Haskell Compiler v.7.4.2 on Linux.

\paragraph{}The database management system of choice is the lightweight embedded DMBS SQLite3. 

\paragraph{}The system also makes use of some external Haskell libraries: 

\begin{itemize}
\item HDBC, the Haskell Database Connectivity library
\item HDBC.SQLite3, SQLite3's backend for HDBC. This library implies
  the presence of Sqlite3.
\item Readline, for a little better I/O in the
  commandline mode. Likewise this library also requires readline
  already on the system
\item Template Haskell, a metaprogramming library for Haskell
\item SelfRestart, a very small library providing the ability for a
  process to restart itself. Unlike other library mentioned here, this
  one is included in the source of the program so there's no need to
  install it beforehand.
\item ... and some other libraries, all of them should be installed
  along with the default Haskell Platform 
\end{itemize}



\section{System Design}
\subsection{Database Design}

\subsubsection{Entity-Relationship diagram}
\includegraphics[scale=0.45]{part2/ERDiagram}

\subsubsection{Database schema}
\paragraph{}
\includegraphics[clip=true, trim = 90 0 0 0,
scale=0.8,page=1]{part2/DataModel}
\paragraph{}
\includegraphics[clip=true, trim = 90 200 0 0,
scale=0.8,page=2]{part2/DataModel}
\paragraph{hedges and positive/negative tables:}
The hedges table containing all hedges that was defined in the database, but
in actuallity the system will only consider those actually present in
the positive and negative tables, since any hedge must either be
positive or negative, but can't be neither.\\
The system also prevents users from adding a hedge to both tables, to
guarantee that a hedge would not be both positive and negative.\\
The precedence column in these tables indicate the order of hedge, the
smaller the precedence the stronger the hedge is w.r.t. other hedge in
the same list.
\paragraph{positive/negative relation:}
The user is also restricted to only modify one of these two tables at
a time, since doing both would likely to result in conflicts: remember
that a hedge is either positive or negative to {\em every} other
hedges. 
Once a table is updated, the other table is recalculated and updated
by the system to preserve hedge algebra's consistency.
\paragraph{Clauses and literals:}
These are pretty much just like described in the {\em Problem
  Definition} section. The system would automatically insert new
literals as necessary when updating clauses, or adding new
clauses. Literals can be reused, and appeared in many different
clauses at once. 
\paragraph{hstring:}
This table is actually a linked list data structure representing
the sequence of hedge in a truth value. Each ``sequence'' has its id,
its ``head'' (a hedge id) and its ``tail'', which is a reference to
its subsequence. Many different sequences can share the same
subsequence.\\
Every literal has a reference to a hstring id, which is the ``hedge'' part
of its truth value.
\subsection{Use cases}

\subsubsection{Use cases diagram}
\includegraphics[scale=0.85]{part2/UsecaseDiagram}

\subsubsection{Use cases specification}
{\huge //TODO}

%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=1]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=2]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=3]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=4]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=5]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=6]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=7]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=8]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=9]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=10]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=11]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=12]{part2/UCdesc}


\section{Architectural design}
\subsection{Modular Decomposition}
\includegraphics[scale=0.78]{part2/_Modules}
\paragraph{}
\includegraphics[width=450pt, height=600pt]{part2/Modules}
\paragraph{} Reflecting the specification, the system is decomposed
into different groups of modules, each solving a relatively logically separated
concern:
\begin{itemize}
\item {\bfseries Hedge Algebra implementation concerns:} dealing with
  the implementation of this particular mathematical structure, and
  its runtime instantialization based on user's definition. This
  group consists of HedgeClass module and the modules in Hedgen:
  Hgen and Ahedge.
\item {\bfseries Linguistic Propositional Logic implementation concerns:} dealing
  with the implementation and representation of the aforementioned
  propositional logic. This group is dependent on the previous group's
  HedgeClass module. There are two modules in this group: HedgeTruth
  and ProsLogic.
\item {\bfseries Database interaction concerns:} dealing with
        database operations, which furtherly decomposed into:
        \begin{itemize}
          \item {\bfseries Hedge definition management concerns:}
                  dealing with the creation and management of
                  user-defined hedge algebra, which is one of the
                  main functionalities of the system. Hio is the
                  only module in this group. 
          \item {\bfseries KnowlegeBase management concerns:}
                  dealing with the creation and management of
                  knowledgebase, which is also one of the main
                  functionalities of the system. KBio is the only
                  module here.
        \end{itemize}
\item {\bfseries Automated reasoning concerns:} dealing with the
  reason-to-exist of the system: implementation of automated reasoning
  on linguistic logic using Alpha Resolution. This is the main
  functionalities of this system. The module in this system is,
  accordingly, AlphaResolution.
\end{itemize}
\subsubsection{Module HedgeClass}

\paragraph{}This module defines the Ha (short for Hedge algebra) typeclass, which is used as a basis for  actual hedge algebra. An instance Hedge of Ha (i.e. is the type for linguistic hedges) must define:

\begin{itemize}
\item A list of all linguistic hedges in the type Either a list of all
  positive hedges or a list of all negative hedges, or both list
\item  Either a positive relationship matrix, or a negative relationship
  matrix
\end{itemize}

\paragraph{}The Ha typeclass will accordingly generate:

\begin{itemize}
\item Operator <+> and <-> e.g. Very <+> Less = True means Very is
  positive w.r.t. Less, Less <-> Possibly = True means Less is
  negative w.r.t. 
\item Possibly Predicate positive and negative: Hedge ->
  Bool Comparing function compare': Hedge x Hedge -> LT | EQ | GT
\end{itemize}

\paragraph{}The HedgeClass module exports the typeclass Ha.

\subsubsection{Module HedgeTruth}


\paragraph{}This module defines the parametric type Truth. Given
a type Hedge that is an instance of Ha, this parametric type will
construct an actual linear symmetrical hedge algebra, with two
generators: Tru being the positive one, Fals being the negative
one. \\

\paragraph{}As an instance of the typeclass Ord, the compare
function for Truth is also defined in this module, and is used as
a basis for defining logical connectives for linguistic truth
value.\\

\paragraph{}This module depends on the HedgeClass module, exports the type Truth, and the following functions:

\begin{itemize}
\item isHTrue, isHFalse: test whether if a truth value has True or
  False tendency 
\item andH, orH, notH: and, or and not counterparts for
  linguistic truth value 
\item operator (><): test whether if two linguistic
  truth value has opposite tendency or not
\end{itemize}


\subsubsection{Module ProsLogic}

\paragraph{}The representations for literals and clauses of the propositional language are defined here. It exports the Lit and CNF types and their type accessors/constructors. This module depends on the two modules HedgeClass and HedgeTruth.


\subsubsection{Module AlphaResolution}

\paragraph{}The implementation of Alpha Resolution method and its auxiliary functions are defined in this module. This resolution function takes a set of clauses and performs Alpha Resolution on it. The returned value is of the type Maybe (Truth hedge), where it can be Nothing if the resolution didn't entail the null clause, or Just <truth value> if it did.\\

\paragraph{}This module depends on HedgeClass, HedgeTruth and ProsLogic modules and exports the resolution procedure.

\subsubsection{Component Hedgen}

\subparagraph{Module Hgen:} This module generate the declaration for the Hedge type
according to the description in the hedge database. Hedge will be an
instance of Ha, and this module will export this declaration.\\
To preserve type safety, Template Haskell requires that the declaration
generation and the actual declaration must be in two different
modules, so there must be another module to generate the actual Hedge type.\\
This module depends on the libraries Template Haskell, HDBC,
HDBC.SQLite3, the module Hio and using utilities from UtilB.\\
\subparagraph{Module Ahedge:} This is where the actual hedge type is
generated. This module just simply generates the type, and exports it
to the outside world.

\subsubsection{Component DBio:}
\subparagraph{Module Hio:} This module handles the operation on the
hedge definition tables in the database. It uses HDBC and
HDBC.Sqlite3, SelfRestart and module UtilB.
\subparagraph{Module KBio:} This module handles the operations on the
knowledge base DB. It depends on the libraries HDBC, HDBC.SQLite3 and UtilA, and exports the read, update and delete procedures.
\subsubsection{Component Util:}
\paragraph{} Because there are both some utility functions that are useful
both before and after the Hedge type is generated, and some other
utility functions that can only be meaningful after the generation of
that type, there are accordingly two utility providing modules: UtilB
for the former, and UtilA for the latter.
\subparagraph{Module UtilB:} This module provides some small utility
functions that don't depend on the presence of a Hedge type
\subparagraph{Module UtilA:} Likewise, but dependent on the presence of
type Hedge. It also reexport a bunch of other modules: Ahedge,
ProsLogic, AlphaResolution, Hio, SelfRestart and also UtilB itself.

\subsubsection{Module Main}

\paragraph{}This module is in charge of user interaction. The main
loop is defined here.
\section{System Implementation}

\subsection{Module HedgeClass}

\subsubsection{Import and Export:}

\begin{lstlisting}
module HedgeClass (
        Ha(..),
) where
import Data.List
\end{lstlisting}

\subsubsection{Description} Definition for the general LSHA mathematical
structures. Export Ha typeclass and all of its methods.
\subsubsection{Hedge typeclass}
\begin{lstlisting}
class (Eq a,Ord a,Enum a,Show a,Read a) => Ha a where
\end{lstlisting}

\paragraph{} A type class of linear symmetrical hedge algebras. This type
class captures the abstract algebraic structure of every LSHA,
but omits the positive and negative spanning terms and leaves
them to the logic definition to decide.\\

\emph{Properties:}
\begin{enumerate}
        \item h `elem` hedgeLs => h `elem` posLs OR h `elem` negLs
        \item h, k `elem` posLs/negLs => h >= k OR k >= h
        \item h, k `elem` hedgeLs => h <+> k OR h <-> k
\end{enumerate}
\paragraph{}
\emph{Methods}

\begin{enumerate}
        \item hedgeLs :: [a] - List of every hedge in the structure

        \item posLs :: [a]\\
        List of positive hedges

        \item negLs :: [a]\\
           List of negative hedges

        \item  positive :: Ha a => a -> Bool\\
           Test for the positivity of a hedge

        \item  negative :: Ha a => a -> Bool\\
          Test for the negativity of a hedge

        \item  allRel :: [(a, a)]\\
          Every relations in the structures. This list is used in the
          construction of the lists of positive and negative relations.
        \item  posRel :: [(a, a)]\\
          List of positive relations between hedges

        \item  negRel :: [(a, a)]\\
          List of negative relations between hedges

        \item  (<+>) :: a -> a -> Bool\\
          isPositive operation: h <+> k iff h is positive w.r.t k
        \item  (<->) :: a -> a -> Bool\\
          isNegative operation: h <-> k iff h is negative w.r.t k
        \item  compare' :: a -> a -> Ordering\\
          Generic comparing function for the structure. This is used in
          the Ord instance declaration of the structure
\end{enumerate}
Instances Ha Hedge defined in {\bfseries Ahedge}

\subsection{Module Hedgen.Hgen}
\subsubsection{Import and Export:}

\begin{lstlisting}
module Hedgen.Hgen  (
        q,
) where
import Language.Haskell.TH
import System.Console.Readline
import System.Environment
import Database.HDBC
import Database.HDBC.Sqlite3
import Util.UtilB
import DBio.Hio
import System.Directory(doesFileExist)
import Control.Monad
import Control.Exception
import SelfRestart(ExitCode(..),selfRestart,exitImmediately)
import Data.Char(toLower) 
\end{lstlisting}        
\subsubsection {Description} Generating a Hedge {\em declaration generator} from input knowledge
base's definition. The generator is exported to module Ahedge and
the Hedge is defined there.\\
This is also the first entry point of the program: while the sole
purpose is just to generate the declaration for Hedge, this
module will also take care of the case when the knowledge base is
not initialized, or there is no hedge definition in the knowledge
base.
\subsubsection{Hedge generator:}
\begin{lstlisting}
q :: Q [Dec]
\end{lstlisting}
The generator's type means that it is a {\em monadic} value of
an abstract syntax tree for a Haskell's declaration. This
abstract syntax tree will then be used to generate the
declaration code for the type Hedge.\\
The language extension TemplateHaskell makes this kind of metaprogramming
possible.
\subsubsection{Internal definition:}
\begin{itemize}
 \item hedgeDef :: [String] -> [String] -> [String] -> [[String]] ->
         [[String]] -> [Dec]\\
         This function takes the hedge definition's information
         extracted from the knowledge base and construct the
         abstract syntax tree of the declaration.

 \item cliGen :: FilePath -> IO [Dec]\\
         This IO function takes the path to the knowledge base
         and gets hedge definition from it, passes the
         definition to the aforementioned hedgeDef then returns
         the generated abstract syntax tree.\\
         It also performs initialization if the input knowledge
         base is a new file.
 \item startup :: IO [Dec]\\
         Wrapper around cliGen, to catch any unexpected
         exception. q will be created from this IO value.

 \item bulkQuery :: FilePath -> [String] -> IO [Integer]\\
       initSchema :: [String]\\
       Initialization for new knowledge base.
\end{itemize}

\subsection{Module Hedgen.Ahedge}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Hedgen.Ahedge (
        Hedge(..),
) where
import Hedgen.Hgen
import HedgeClass
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
\end{lstlisting}
\subsubsection{Description} Importing the generator q from Hgen and generating the
declaration for the type Hedge from q.\\
This module also defines the instance declaration of Ord
typeclass for Hedge using the Ha typeclass' method compare'. This
enables values of Hedge to use general comparing operation like <
or >= just like other Haskell's ordered types.
\subsubsection{Internal definition}
\begin{itemize}
        \item data Hedge = ... \\
                generated from Hgen.q\\
                {\bfseries Instances: }
         \begin{itemize}
                 \item Enum Hedge 
                 \item Eq Hedge 
                 \item Ord Hedge
                 \item Read Hedge 
                 \item Show Hedge 
                 \item Ha Hedge
        \end{itemize}
        \item instance Ord Hedge where compare = compare'\\
                Ord instance definition for Hedge                
\end{itemize}

\subsection{Module HedgeTruth}
\subsubsection{Import and Export:}
\begin{lstlisting}
module HedgeTruth (
        Truth(..),
        module HedgeClass,
        module Data.List,
        isHTrue,
        isHFalse,
        andH,
        orH,
        notH,
        (><)) where
import
HedgeClass
import
Data.List
\end{lstlisting}
\subsubsection{Description}

\subsubsection{Internal Definition}
data Truth hedge

Constructors
Tru [hedge]
Fals [hedge]
Maxt 
Mint 

Instances
Eq hedge => Eq (Truth hedge)
Ha h => Ord (Truth h)
Read hedge => Read (Truth hedge)
Show h => Show (Truth h)

isHTrue :: Truth h -> Bool

isHFalse :: Truth h -> Bool

andH :: Ha h => Truth h -> Truth h -> Truth h

orH :: Ha h => Truth h -> Truth h -> Truth h

notH :: Ha h => Truth h -> Truth h

(><) :: Ha h => Truth h -> Truth h -> Bool

\subsection{Module ProsLogic}
\subsubsection{Import and Export:}
\begin{lstlisting}
module ProsLogic (
        Lit(..),
        CNF(..),
        truthLit,
        stringLit,
        lsCNF,
        smartCNF,
        sortCNF,
        sortLits,
        negateLit,
        module HedgeTruth,
        module HedgeClass,
        module Data.List
) where
import HedgeTruth
import HedgeClass
import Data.List
\end{lstlisting}

\subsubsection{Description}
\subsubsection{Internal Definition}

data Lit hedge

Constructors
Lit String (Truth hedge)subsection 

Instances
Eq hedge => Eq (Lit hedge)subsection 
Read hedge => Read (Lit hedge)subsection 
Show hedge => Show (Lit hedge)subsection 

truthLit :: Lit t -> Truth t

stringLit :: Lit t -> String

data CNF a

Constructors
CNF [a]subsection 

Instances
Show a => Show (CNF a)subsection 

lsCNF :: CNF t -> [t]

negateLit :: Ha hedge => Lit hedge -> Lit hedge

smartCNF :: Ha hedge => [Lit hedge] -> CNF (Lit hedge)

sortCNF :: Ha hedge => CNF (Lit hedge) -> CNF (Lit hedge)

sortLits :: Ha hedge => [Lit hedge] -> [Lit hedge]

\subsection{Module AlphaResolution}
\subsubsection{Import and Export:}
\begin{lstlisting}
module AlphaResolution (
        module HedgeClass,
        module HedgeTruth,
        module ProsLogic,
        module Data.List,
        smartClause,
        confidence,
        resolvent',
        resolution,
        resolution',
        resolution'',
        nilH,
        rmTau,
        Debug.Trace.trace,
        Clause(..)
)
where
import Data.List
import HedgeClass
import HedgeTruth
import ProsLogic
import Debug.Trace
\end{lstlisting}
\subsubsection{Description}

\subsubsection{Internal Definition}
type Clause hedge = ([Lit hedge], Truth hedge)

nilH :: Ha hedge => Lit hedge

smartClause :: Ha hedge => CNF (Lit hedge) -> Truth hedge ->
Clause hedge

confidence :: Ha h => Truth h -> Truth h -> Truth h -> Truth h ->
Truth h

resolution :: Ha hedge => [([Lit hedge], Truth hedge)] -> (Maybe
(Truth hedge), [(([Lit hedge], Truth hedge), ([Lit hedge], Truth
hedge), ([Lit hedge], Truth hedge))])

resolution' :: Ha hedge => [([Lit hedge], Truth hedge)] ->
[(([Lit hedge], Truth hedge), ([Lit hedge], Truth hedge))] ->
[(([Lit hedge], Truth hedge), ([Lit hedge], Truth hedge), ([Lit
hedge], Truth hedge))] -> [(String, Maybe t)] -> (Maybe (Truth
hedge), [(([Lit hedge], Truth hedge), ([Lit hedge], Truth hedge),
([Lit hedge], Truth hedge))])

rmTau :: Ha h => [([Lit h], t)] -> [([Lit h], t)]

resolvent' :: Ha hedge => Clause hedge -> Clause hedge -> Maybe
[Clause hedge]

resolution'' :: Ha hedge => [([Lit hedge], Truth hedge)] ->
[(([Lit hedge], Truth hedge), ([Lit hedge], Truth hedge))] ->
Maybe (Truth hedge)

\subsection{Module Hio}
\subsubsection{Import and Export:}
\begin{lstlisting}
module DBio.Hio(
  hManager,
  hMMenu,
  printPosH,
  printNegH,
  ) where
import SelfRestart
import Util.UtilB
import Database.HDBC
import Database.HDBC.Sqlite3
import Control.Monad
import Data.Char
import SelfRestart(selfRestart,exitImmediately,ExitCode(..))
import System.Environment(getProgName)
\end{lstlisting}
\subsubsection{Description}

\subsubsection{Internal Definition}
printlH :: IConnection conn => String -> conn -> IO ()

printPosH :: IConnection conn => conn -> IO ()

printNegH :: IConnection conn => conn -> IO ()

removeH :: String -> String -> IO ()

removelH :: String -> String -> String -> IO ()

removePosH :: String -> String -> IO ()

removeNegH :: String -> String -> IO ()

addlH :: String -> String -> String -> String -> String -> IO ()

addNegH :: String -> String -> String -> String -> IO ()

addPosH :: String -> String -> String -> String -> IO ()

changeOrd :: String -> String -> String -> String -> IO ()

changePosOrd :: String -> String -> String -> IO ()

changeNegOrd :: String -> String -> String -> IO ()

renameHedge :: String -> String -> String -> IO ()

addlRel :: String -> String -> String -> String -> IO ()

addPosRel :: String -> String -> String -> IO ()

addNegRel :: String -> String -> String -> IO ()

removelRel :: String -> String -> String -> String -> IO ()

removePosRel :: String -> String -> String -> IO ()

removeNegRel :: String -> String -> String -> IO ()

hMMenu :: [String]

hManager :: String -> IO ()

printHedges :: String -> IO ()
\subsection{Module KBio}
\subsubsection{Import and Export:}
\begin{lstlisting}
module DBio.KBio 
where
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution
import Util.UtilA
\end{lstlisting}
\subsubsection{Description}

\subsubsection{Internal Definition}
sid\_to\_hstring :: FilePath -> SqlValue -> IO [String]

hStringtoHid :: String -> [String] -> IO (Maybe [SqlValue])

find\_sid :: IConnection conn => conn -> ([SqlValue], SqlValue,
[SqlValue]) -> IO ([SqlValue], SqlValue, [SqlValue])

insert\_if\_not\_exist\_sid :: String -> [Char] -> IO (Maybe
SqlValue)

getCid :: String -> IO [String]

getCNF :: String -> IO [CNF (Lit Hedge)]

parseGoal :: String -> Lit Hedge

parseGoals :: String -> [Lit Hedge]

parseInpClause :: [Char] -> [[[Char]]]

changeByCID :: String -> String -> String -> IO ()

changeClause :: String -> [Char] -> String -> IO ()

deleteByCID :: String -> String -> IO ()

deleteClause :: String -> [Char] -> IO ()

addClause :: String -> [Char] -> IO ()

\subsection{Module UtilA}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Util.UtilA (
    okTruthStr,
    toClause,
    printClauses,
    printLits,
    prove,
    printHedges,    
    nil,
    headIs,
    findHead,
    retrace,
    module SelfRestart,
    module Util.UtilB, 
    module DBio.Hio
  ) where
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution

import Data.IORef
import Data.List.Split
import Data.Char

import Database.HDBC
import Database.HDBC.Sqlite3

import System.Environment
import System.Console.Readline

import Control.Concurrent
import Control.Monad
import Util.UtilB
import DBio.Hio
import SelfRestart (selfRestart,
forkSelfRestartExePollWithAction, exitImmediately, ExitCode(..))

\end{lstlisting}
\subsubsection{Description}

\subsubsection{Internal Definition}
okTruthStr :: [Char] -> Bool

toClause :: Ha hedge => [CNF (Lit hedge)] -> [Clause hedge]

printClauses :: Show a => [([a], t)] -> IO ()

printLits :: Ha hedge => [CNF (Lit hedge)] -> IO ()

prove :: Ha hedge => [CNF (Lit hedge)] -> CNF (Lit hedge) ->
(Maybe (Truth hedge), [(([Lit hedge], Truth hedge), ([Lit hedge],
Truth hedge), ([Lit hedge], Truth hedge))])

printHedges :: FilePath -> IO ()

nil :: [Lit Hedge]

headIs :: Eq a => a -> (a, t, t1) -> Bool

findHead :: Eq a => a -> [(a, t, t1)] -> Maybe (a, t, t1)

retrace :: (Eq t, Show t) => t -> [(t, t, t)] -> [t] -> [Char]
\subsection{Module UtilB}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Util.UtilB (
    properFormat,
    properTruthString,
    fromQuery,
    readline'
  ) where
import Data.IORef
import Data.List.Split
import Data.Char

import Database.HDBC
import Database.HDBC.Sqlite3

import System.Environment
import System.Console.Readline

import Control.Concurrent
import Control.Monad
\end{lstlisting}
\subsubsection{Description}

\subsubsection{Internal Definition}
properFormat :: String -> String

properTruthString :: String -> [String]

fromQuery :: [[SqlValue]] -> [[String]]

readline' :: IO String

\subsection{Module Main}
\subsubsection{Import and Export:}
\subsubsection{Description}
\subsubsection{Internal Definition}

\end{document}
