\documentclass[../gr-final.tex]{subfiles}
\begin{document}
\lstset{language=Haskell}
%\subfile{chap1}
\part{Results}
\chapter{System's Design and Implementation}

\paragraph{} The system in this report is a reasoning system using a
propositional logic with user-defined linear symmetrical hedge algebra
as the domain of truth value. The reasoning method to be used is the
aforementioned Alpha Resolution in the previous part.
	
\paragraph{} The main objective of implementing this system is to demonstrate the applicability and feasibility of automated linguistic logic reasoning systems based on linear symmetrical hedge algebra, to design and implement a system for developing knowledge bases capable of capturing fuzzy linguistic 
concepts, using user-defined LSHA-based truth value domain, as an alternative to traditional fuzzy logic knowledge base.



\section{Problem Specification}

\paragraph{}Essentially, the problem to be solved by this system is,
with a user-defined linear symmetrical hedge algebra (LSHA) as a truth value
domain, a knowledgebase in the form of hedge algebra based
propositional CNF, if a user had a proposition of the form
\(A^{truth-value}\), the system should be able to tell if this
proposition is true or not, and with as much confidence as it could guarantee.\\
In addition, the system must also provide the
functionality to create, update and manage knowledgebase and
hedge algebra definition. 

\paragraph{}The input of the program is a database describing the hedge algebra to be used, and another database where the knowledge base is stored.\\
The hedge definition including the tables below:
\begin{itemize}
\item A table defining the hedges of the LSHA, containing each hedge's
  unique name and id.
\item Two tables for the positive/negative hedges, and their precedence/ranking.
\item Two tables defining the positive and negative relationships 
  between hedges.
\end{itemize}

\paragraph{}The generator terms of the hedge algebras are always True
and False, so they don't need to be specified in the truth domain's
definition. There are also two other truth constant: Maxt for the
maximum truth value, and Mint for the minimum truth value, regardless
of the set of hedges.\\ 

\paragraph{}The knowledgebase database including:

\begin{itemize}
\item A table describing disjunctive clauses, including their id and
  optionally their label. 
\item A table of literals used in the KB's clauses, with their id,
  name, and two columns to determine their truth value supscribe: sid
  is a reference to the table of sequences of hedges, and seed is one
  of the four generator terms: True, False, Maxt or Mint.
\item A table describing sequences of hedges, including their id,
  their ``head'' hedge's id, and their ``tail'' sequences of hedges
  id, which is a reference to this table itself. 
\item A table relating clauses with the literals they use, with two
  columns being reference to clauses table and literals table, respectively
\end{itemize}

\paragraph{} The Output is either a linguistic truth value, which is
the confidence of the resolution process on the queried clause, or
literally a Nothing value if that clause were unprovable.

\section{High level Requirements}
\subsection{Functional Requirements}
\begin{itemize}
\item Enable user defined hedge algebra structure, and allow user to
  manage the definition of said structure.
\item Enforcing hedge algebra laws on the user defined hedges
\item Allow user to use, create and manage fuzzy knowledgebase
\item Able to answer user's query by proving it
\end{itemize}

\subsection{Non- Functional Requirements}
\begin{itemize}
\item The system should have acceptable performance
\item The system should be easy to use
\item The reasoning functionality must be {\em sound} and {\em complete}.
%\item The system should be easy to maintain and extend
\end{itemize}

%\subsection{Quality Attributes}

%\paragraph{Correctness:}

%\paragraph{Maintainability:}

\section{System configuration}

\paragraph{}The programming language being used is Haskell, a purely functional programming language. The particular implementation of Haskell used for this system is the Glasgow  Haskell Compiler v.7.4.2 on Linux.

\paragraph{}The database management system of choice is the lightweight embedded DMBS SQLite3. 

\paragraph{}The system also makes use of some external Haskell libraries: 

\begin{itemize}
\item HDBC, the Haskell Database Connectivity library
\item HDBC.SQLite3, SQLite3's backend for HDBC. This library implies
  the presence of Sqlite3.
\item Readline, for a little better I/O in the
  commandline mode. Likewise this library also requires readline
  already on the system
\item Template Haskell, a metaprogramming library for Haskell
\item SelfRestart, a very small library providing the ability for a
  process to restart itself. Unlike other library mentioned here, this
  one is included in the source of the program so there's no need to
  install it beforehand. Its description will not be included in
  the design, however.  
\end{itemize}



\section{System Design}
\subsection{Database Design}

\begin{figure}[H]
\includegraphics[scale=0.45]{part2/ERDiagram}
\caption{Entity-relationship diagram modeling the relation
between data of the system}
\end{figure}
\subsubsection{Database schema}
\paragraph{}

%\begin{figure}[H]
%\includegraphics[clip=true, trim = 90 0 0 0,
%scale=0.8,page=1]{part2/DataModel}
%\end{figure}
%\begin{figure}[H]
%\includegraphics[clip=true, trim = 90 200 0 0,
%scale=0.8,page=2]{part2/DataModel}
%\caption{Database schema of the system}
%\end{figure}

\begin{table}[H]
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
      No & Column name & Private key & Foreign key & Unique & Data type   & Description   \\ \hline
      1  & HID         & X           & ~           & X      & Numeric     & ID of a hedge \\ \hline
      2  & Name        & ~           & ~           & X      & Varchar(60) & Hedge name    \\ \hline
\end{tabular}
\caption {Table hedges}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID         & ~           & X           & X      & Numeric   & ID of a hedge         \\ \hline
    2  & precedence  & ~           & ~           & X      & Numeric   & For determining order \\ \hline
    \end{tabular}
    \caption {Table posl (Positive hedge list)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID         & ~           & X           & X      & Numeric   & ID of a hedge         \\ \hline
    2  & precedence  & ~           & ~           & X      & Numeric   & For determining order \\ \hline
    \end{tabular}
    \caption {Table negl (Negative hedge list)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID1        & ~           & X           & ~      & Numeric   & ID of affecting hedge \\ \hline
    2  & HID2        & ~           & X           & ~      & Numeric   & ID of affected hedge  \\ \hline
    \end{tabular}
    \caption {Table posrel (Positive relation matrix)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description           \\ \hline
    1  & HID1        & ~           & X           & ~      & Numeric   & ID of affecting hedge \\ \hline
    2  & HID2        & ~           & X           & ~      & Numeric   & ID of affected hedge  \\ \hline
    \end{tabular}
    \caption {Table negrel (Negative relation matrix)}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type    & Description    \\ \hline
    1  & CID         & X           & ~           & X      & Numeric      & ID of a Clause \\ \hline
    2  & label       & ~           & ~           & ~      & Varchar(256) & Optional label \\ \hline
    \end{tabular}
    \caption {Table conj (Clauses of the knowledge base )}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type    & Description                           \\ \hline
    1  & LID         & X           & ~           & X      & Numeric      & ID of a literal                       \\ \hline
    2  & sentence    & ~           & ~           & ~      & Varchar(256) & literal's sentence                    \\ \hline
    3  & SID         & ~           & X           & ~      & Numeric      & ID of a hedge string                  \\ \hline
    4  & genterm     & ~           & ~           & ~      & Varchar(20)  & A fuzzy truth value's generator term \\ \hline
    \end{tabular}
    \caption {Table literal (Literals of the clauses of the knowledge base )}
\end{table}

\begin{table}[H]
        \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description     \\ \hline
    1  & CID         & X           & X           & ~      & Numeric   & ID of a Clause  \\ \hline
    2  & LID         & X           & X           & ~      & Numeric   & ID of a literal \\ \hline
    \end{tabular}
    \caption {Table conjLits (Literals - Clauses many-to-many relationship)}
\end{table}


\begin{table}[H]
                \begin{tabular}{|l|c|c|c|c|c|p{2cm}|}
    \hline
    No & Column name & Private key & Foreign key & Unique & Data type & Description                                    \\ \hline
    1  & SID         & X           & ~           & X      & Numeric   & ID of a hedge string                           \\ \hline
    2  & HID         & ~           & X           & ~      &
    Numeric   & \parbox{2cm}{ID of \\the `head'\\ hedge of \\this
    hedge string} \\ \hline
    3  & tail        & X           & X           & ~      & Numeric   & ID of the `tail' hedge string                 \\ \hline
    \end{tabular}
    \caption {Table hstring (hedges in truth value of literals)}
\end{table}

\paragraph{hedges and positive/negative tables:}
The hedges table containing all hedges that was defined in the database, but
in actuallity the system will only consider those actually present in
the positive and negative tables, since any hedge must either be
positive or negative, but can't be neither.
\paragraph{} The system also prevents users from adding a hedge to both tables, to
guarantee that a hedge would not be both positive and negative.
\paragraph{} The precedence column in these tables indicate the order of hedge, the
smaller the precedence the stronger the hedge is w.r.t. other hedge in
the same list. To preserve the consistency of ordering in the two
positive/negative tables, two triggers are defined for each
table:\\
\begin{lstlisting}
CREATE TRIGGER posl_delete  
AFTER DELETE ON posl  
BEGIN
UPDATE posl SET pred = pred - 1          
WHERE posl.pred >= OLD.pred 
      AND posl.hid != OLD.hid;
END;

CREATE TRIGGER posl_insert   
AFTER INSERT ON posl   
BEGIN
UPDATE posl SET pred = pred + 1
WHERE posl.pred >= NEW.pred 
      AND posl.hid != NEW.hid;  
END;
_______________________________

CREATE TRIGGER negl_delete  
AFTER DELETE ON negl  
BEGIN
UPDATE negl SET pred = pred - 1
WHERE negl.pred >= OLD.pred 
      AND negl.hid != OLD.hid;  
END;

CREATE TRIGGER negl_insert   
AFTER INSERT ON negl   
BEGIN
UPDATE negl SET pred = pred + 1        
WHERE negl.pred >= NEW.pred 
      AND negl.hid != NEW.hid;  
END;
\end{lstlisting}

\paragraph{positive/negative relation:}
The user is also restricted to only modify one of these two tables at
a time, since doing both would likely to result in conflicts: remember
that a hedge is either positive or negative to {\em every} other
hedges. 
Once a table is updated, the other table is recalculated and updated
by the system to preserve hedge algebra's consistency.
\paragraph{Clauses and literals:}
These are pretty much just like described in the {\em Problem
  Definition} section. The system would automatically insert new
literals as necessary when updating clauses, or adding new
clauses. Literals can be reused, and appeared in many different
clauses at once. 
\paragraph{hstring:}
This table is actually a linked list data structure representing
the sequence of hedge in a truth value. Each ``sequence'' has its id,
its ``head'' (a hedge id) and its ``tail'', which is a reference to
its subsequence. Many different sequences can share the same
subsequence.\\
Every literal has a reference to a hstring id, which is the ``hedge'' part
of its truth value.
\subsection{Use cases}

\begin{figure}[H]
\includegraphics[scale=0.85]{part2/UsecaseDiagram}
\caption{Use cases diagram of the system}
\end{figure}

\subsubsection{Use cases Overview}
\paragraph{} There are three main use cases:
\begin{itemize}
  \item {\bfseries Prove} concerns with using the system to prove
    a proposition w.r.t. to a KB. This use case extends to
    Explain use case,
    which concerns with explaining the proof.    
  \item {\bfseries Managing KB's hedges} concerns with using the
    system to managing the hedge algebra of a KB. This use case
    includes add/edit/remove use cases for each hedges list, for
    for positive and negative relations and print specification
    about the hedge algebra.
  \item {\bfseries Managing KB's clauses} concerns with using the
    system to managing the knowledge base. This use case includes
    add/remove/edit use cases for clauses, print KB, and check
    for KB's consistency usecases.    
\end{itemize}
\paragraph{} Some major use cases will be illustrated in more detail in
the {\bfseries Sample Execution of the System} section.
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=1]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=2]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=3]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=4]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=5]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=6]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=7]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=8]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=9]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=10]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=11]{part2/UCdesc}
%\includegraphics[clip=true, trim = 50 0 0 0, scale=0.8, page=12]{part2/UCdesc}


\section{Architectural design}

\subsection{Modular Decomposition}
\begin{figure}[H]
\includegraphics[scale=0.78]{part2/_Modules}
\caption{Module dependency graph}
\end{figure}
\paragraph{}For reference purpose, below is the complete dependency
graph of the system, including the external libraries used.
\begin{figure}[H]
\includegraphics[width=450pt, height=600pt]{part2/Modules}
\caption{Complete dependency graph}
\end{figure}

\paragraph{} Reflecting the specification, the system is decomposed
into different groups of modules, each solving a relatively logically separated
concern:
\begin{itemize}
\item {\bfseries Hedge Algebra implementation concerns:} dealing with
  the implementation of this particular mathematical structure, and
  its runtime instantialization based on user's definition. This
  group consists of HedgeClass module and the modules in Hedgen:
  Hgen and Ahedge.
\item {\bfseries Linguistic Propositional Logic implementation concerns:} dealing
  with the implementation and representation of the aforementioned
  propositional logic. This group is dependent on the previous group's
  HedgeClass module. There are two modules in this group: HedgeTruth
  and ProsLogic.
\item {\bfseries Database interaction concerns:} dealing with
        database operations, which furtherly decomposed into:
        \begin{itemize}
          \item {\bfseries Hedge definition management concerns:}
                  dealing with the creation and management of
                  user-defined hedge algebra, which is one of the
                  main functionalities of the system. Hio is the
                  only module in this group. 
          \item {\bfseries KnowlegeBase management concerns:}
                  dealing with the creation and management of
                  knowledgebase, which is also one of the main
                  functionalities of the system. KBio is the only
                  module here.
        \end{itemize}
\item {\bfseries Automated reasoning concerns:} dealing with the
  reason-to-exist of the system: implementation of automated reasoning
  on linguistic logic using Alpha Resolution. This is the main
  functionalities of this system. The module in this system is,
  accordingly, AlphaResolution.
\end{itemize}
\paragraph{} The following section briefly overviews the modules in
the system.
\subsubsection{Module HedgeClass}

\paragraph{}This module defines the Ha (short for Hedge algebra) typeclass, which is used as a basis for  actual hedge algebra. An instance Hedge of Ha (i.e. is the type for linguistic hedges) must define:

\begin{itemize}
\item A list of all linguistic hedges,  a list of all
  positive hedges or a list of all negative hedges, or both list
\item  Either a positive relationship matrix, or a negative relationship
  matrix
\end{itemize}

\paragraph{}The Ha typeclass will accordingly automatically define the
follinging methods for its instance:

\begin{itemize}
\item Operator <+> and <-> : determine the positivity/negativity
  relation between two hedges, e.g. Very <+> Less = True means Very is
  positive w.r.t. Less, Less <-> Possibly = True means Less is
  negative w.r.t. 
\item positive and negative: predicate to determine whether a hedge is
  a positve/negative hedge or not
  Bool\item  Hedges comparing function compare': compares if a hedge
  is greater than, equal or less than the other: Hedge -> Hedge -> LT | EQ | GT 
\end{itemize}

\paragraph{}The HedgeClass module exports the typeclass Ha and its methods .

\subsubsection{Module HedgeTruth}


\paragraph{}This module defines the parametric type Truth. Given
a type Hedge that is an instance of Ha, this parametric type will
construct an actual linear symmetrical hedge algebra, with two
generator terms: True being the positive one, False being the negative
one.
\paragraph{}As an instance of the typeclass Ord, the comparing
function for Truth is also defined in this module, and is used as
a basis for defining logical connectives for linguistic truth
value.
\paragraph{} This module exports the type Truth, and the following functions:

\begin{itemize}
\item isHTrue, isHFalse: test whether if a truth value has True or
  False tendency 
\item andH, orH, notH: and, or and not counterparts for
  linguistic truth value 
\item operator >< : test whether if two linguistic
  truth value has opposite tendency or not
\end{itemize}


\subsubsection{Module ProsLogic}

\paragraph{}The representations for literals and clauses of the
propositional language are defined here. It provides the Lit and CNF types and their type accessors/constructors. 


\subsubsection{Module AlphaResolution}

\paragraph{}The implementation of Alpha Resolution method and its
auxiliary functions are defined in this module. This resolution
function takes a set of clauses and performs Alpha Resolution on
it. The returned value may be a ``Nothing'' if the resolution process didn't entail
the null clause, or a linguistic truth value if it did. It also returns a tracing
tree to represent the resolution process that led to the result.

\paragraph{}This module exports the resolution procedure.

\subsubsection{Component Hedgen}

\paragraph{Module Hgen:} This module generate the declaration for the Hedge type
according to the description in the hedge database. Hedge will be an
instance of Ha, and this module will export this declaration.\\
To preserve type safety, Template Haskell requires that the declaration
generation and the actual declaration must be in two different
modules, so there must be another module to generate the actual Hedge type.\\
This module depends on the libraries Template Haskell, HDBC,
HDBC.SQLite3, the module Hio and using utilities from UtilB.\\
\paragraph{Module Ahedge:} This is where the actual hedge type is
generated. This module just simply generates the type, and exports it
to the outside world.

\subsubsection{Component DBio:}
\paragraph{Module Hio:} This module provides the functionalities to manage the
hedge definition tables in the database. It uses HDBC and
HDBC.Sqlite3, SelfRestart and module UtilB. 
\paragraph{Module KBio:} This module handles the operations on the
knowledge base DB. It depends on the libraries HDBC, HDBC.SQLite3 and
UtilA, and provides the system with the read, update and delete
procedures for clauses in the knowledgebase.
\subsubsection{Component Util:}
\paragraph{} Because there are both some utility functions that are useful
both before and after the Hedge type is generated, and some other
utility functions that can only be meaningful after the generation of
that type, there are accordingly two utility providing modules: UtilB
for the former, and UtilA for the latter.
\subparagraph{Module UtilB:} This module provides some small utility
functions that don't depend on the presence of a Hedge type
\subparagraph{Module UtilA:} Likewise, but dependent on the presence of
type Hedge. It also reexport a bunch of other modules: Ahedge,
ProsLogic, AlphaResolution, Hio, SelfRestart and also UtilB itself.

\subsubsection{Module Main}

\paragraph{}This module is in charge of user interaction. The main
loop is defined here.
\section{System Implementation}
\paragraph{} In this section, we take a closer look at the modules as
described in the Architectural design. Each subsection will have a
definition of a module's interface to the outside, its imported
components, a description of the module, and descriptions for the
definition inside of the module.
\subsection{Module HedgeClass}
\subsubsection{Import and Export:}

\begin{lstlisting}
module HedgeClass (
        Ha(..),
) where
import Data.List
\end{lstlisting}

\subsubsection{Description} Definition for the general LSHA mathematical
structures. Export Ha typeclass and all of its methods.
\subsubsection{Hedge typeclass}
\begin{lstlisting}
class (Eq a,Ord a,Enum a,Show a,Read a) => Ha a where
\end{lstlisting}

\paragraph{} A type class of linear symmetrical hedge algebras. This type
class captures the abstract algebraic structure of every LSHA,
but omits the positive and negative spanning terms and leaves
them to the logic definition to decide.\\

\emph{Properties:}
\begin{enumerate}
        \item h `elem` hedgeLs => h `elem` posLs OR h `elem` negLs
        \item h, k `elem` posLs/negLs => h >= k OR k >= h
        \item h, k `elem` hedgeLs => h <+> k OR h <-> k
\end{enumerate}
\paragraph{}
\emph{Methods}

\begin{enumerate}
        \item hedgeLs :: [a] - List of every hedge in the structure

        \item posLs :: [a]\\
        List of positive hedges

        \item negLs :: [a]\\
           List of negative hedges

        \item  positive :: Ha a => a -> Bool\\
           Test for the positivity of a hedge

        \item  negative :: Ha a => a -> Bool\\
          Test for the negativity of a hedge

        \item  allRel :: [(a, a)]\\
          Every relations in the structures. This list is used in the
          construction of the lists of positive and negative relations.
        \item  posRel :: [(a, a)]\\
          List of positive relations between hedges

        \item  negRel :: [(a, a)]\\
          List of negative relations between hedges

        \item  (<+>) :: a -> a -> Bool\\
          isPositive operation: h <+> k iff h is positive w.r.t k
        \item  (<->) :: a -> a -> Bool\\
          isNegative operation: h <-> k iff h is negative w.r.t k
        \item  compare' :: a -> a -> Ordering\\
          Generic comparing function for the structure. This is used in
          the Ord instance declaration of the structure
\end{enumerate}
Instances Ha Hedge defined in {\bfseries Ahedge}

\subsection{Module Hedgen.Hgen}
\subsubsection{Import and Export:}

\begin{lstlisting}
module Hedgen.Hgen  (
        q,
) where
import Language.Haskell.TH
import System.Console.Readline
import System.Environment
import Database.HDBC
import Database.HDBC.Sqlite3
import Util.UtilB
import DBio.Hio
import System.Directory(doesFileExist)
import Control.Monad
import Control.Exception
import SelfRestart(ExitCode(..),selfRestart,exitImmediately)
import Data.Char(toLower) 
\end{lstlisting}        
\subsubsection {Description} Generating a Hedge {\em declaration generator} from input knowledge
base's definition. The generator is exported to module Ahedge and
the Hedge is defined there.\\
This is also the first entry point of the program: while the sole
purpose is just to generate the declaration for Hedge, this
module will also take care of the case when the knowledge base is
not initialized, or there is no hedge definition in the knowledge
base.
\subsubsection{Hedge generator:}
\begin{lstlisting}
q :: Q [Dec]
\end{lstlisting}
The generator's type means that it is a {\em monadic} value of
an abstract syntax tree for a Haskell's declaration. This
abstract syntax tree will then be used to generate the
declaration code for the type Hedge.\\
The language extension TemplateHaskell makes this kind of metaprogramming
possible.
\subsubsection{Internal definition:}
\begin{itemize}
 \item hedgeDef :: [String] -> [String] -> [String] -> [[String]] ->
         [[String]] -> [Dec]\\
         This function takes the hedge definition's information
         extracted from the knowledge base and construct the
         abstract syntax tree of the declaration.

 \item cliGen :: FilePath -> IO [Dec]\\
         This IO function takes the path to the knowledge base
         and gets hedge definition from it, passes the
         definition to the aforementioned hedgeDef then returns
         the generated abstract syntax tree.\\
         It also performs initialization if the input knowledge
         base is a new file.
 \item startup :: IO [Dec]\\
         Wrapper around cliGen, to catch any unexpected
         exception. q will be created from this IO value.

 \item bulkQuery :: FilePath -> [String] -> IO [Integer]\\
       initSchema :: [String]\\
       Initialization for new knowledge base.
\end{itemize}

\subsection{Module Hedgen.Ahedge}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Hedgen.Ahedge (
        Hedge(..),
) where
import Hedgen.Hgen
import HedgeClass
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
\end{lstlisting}
\subsubsection{Description} Importing the generator q from Hgen and generating the
declaration for the type Hedge from q.\\
This module also defines the instance declaration of Ord
typeclass for Hedge using the Ha typeclass' method compare'. This
enables values of Hedge to use general comparing operation like <
or >= just like other Haskell's ordered types.
\subsubsection{Internal definition}
\begin{itemize}
        \item data Hedge = ... \\
                generated from Hgen.q\\\\
                {\bfseries Instances of: }
         \begin{itemize}
                 \item Enum Hedge 
                 \item Eq Hedge 
                 \item Ord Hedge
                 \item Read Hedge 
                 \item Show Hedge 
                 \item Ha Hedge
        \end{itemize}
        \item instance Ord Hedge where compare = compare'\\
                Ord instance definition for Hedge                
\end{itemize}

\subsection{Module HedgeTruth}
\subsubsection{Import and Export:}
\begin{lstlisting}
module HedgeTruth (
        Truth(..),
        isHTrue,
        isHFalse,
        andH,
        orH,
        notH,
        (><)) where
import
HedgeClass
import
Data.List
\end{lstlisting}
\subsubsection{Description}
This module defines the representation of linguistic truth
values, including the data type for truth value and some
operators on the data type.
\subsubsection{Internal Definition}
\begin{itemize}
\item data Truth hedge - The data type representing linguistic
        truth values.\\\\
        {\bfseries Constructors}
      \begin{itemize}
              \item Tru [hedge] - constructs from a list
                      [$h_1,h_2..h_n$] the value $h_1 h_2 ..
                h_n$ True
        \item Fals [hedge] - constructs from a list
                      [$h_1,h_2..h_n$] the value $h_1 h_2 ..
                h_n$ False 
        \item Maxt - representing the absolutely True value
        \item Mint - representing the absolutely False value
      \end{itemize}
        {\bfseries Instances of:}
        \begin{itemize}
          \item Eq hedge => Eq (Truth hedge)
          \item Ha h => Ord (Truth h)
          \item Read hedge => Read (Truth hedge)
          \item Show h => Show (Truth h)
        \end{itemize}

\item isHTrue :: Truth h -> Bool\\
        Determine if a linguistic truth value is a positive term
        or not
\item isHFalse :: Truth h -> Bool\\
        Determine if a linguistic truth value is a positive term
        or not
\item andH :: Ha h => Truth h -> Truth h -> Truth h\\
        Linguistic logic And
\item orH :: Ha h => Truth h -> Truth h -> Truth h\\
        Linguistic logic Or
\item notH :: Ha h => Truth h -> Truth h\\
        Linguistic logic Not
\item (><) :: Ha h => Truth h -> Truth h -> Bool\\
        Test whether if two linguistic truth values are opposite or not
\end{itemize}

\subsection{Module ProsLogic}
\subsubsection{Import and Export:}
\begin{lstlisting}
module ProsLogic (
        Lit(..),
        CNF(..),
        truthLit,
        stringLit,
        lsCNF,
        smartCNF,
        sortCNF,
        sortLits,
        negateLit,
) where
import HedgeTruth
import HedgeClass
import Data.List
\end{lstlisting}
\subsubsection{Description}
This module defines the propositional fuzzy logic with truth
values being the type defined in module HedgeTruth. Also provides
some utilities to work with Literals and CNF clauses of this
logic.\\
As described below, several utilites are concerned with sorting
list of Literals. This is needed in order to easily test two
CNF clauses for equality. The sorting order is ascending based on
the String sentence in Literals, and if two String sentences are
equal, sort based on the truth value instead.\\
From here on out ``sorting list of Literals'' will by default
mean ``sorting list of Literals'' using the above order unless it
was explicitly said otherwise.
\subsubsection{Internal Definition}
\begin{itemize}
        \item data Lit hedge - A type representing Literals in this propositional fuzzy
                logic\\\\
         {\bfseries Constructors}
         \begin{itemize}
                 \item  Lit String (Truth hedge) - Construct a
                         Literal from a string being its sentence and a truth value 
         \end{itemize}
         {\bfseries Instances of:}
          \begin{itemize}
            \item Eq hedge => Eq (Lit hedge)
            \item Read hedge => Read (Lit hedge) 
            \item Show hedge => Show (Lit hedge)
          \end{itemize}

         \item data CNF a - A disjunction of Literals\\\\
         {\bfseries Constructors}
         \begin{itemize}
          \item CNF [a] - Construct a disjunction of Literals
                  from a list of Literals.
         \end{itemize}
        {\bfseries Instances of:}
        \begin{itemize}
         \item Show a => Show (CNF a)
        \end{itemize}

\item truthLit :: Lit String (Truth t) -> Truth t\\
                Get the truth value of a Literal
        \item stringLit :: Lit String (Truth t) -> String\\
                Get the sentence of a Literal
        \item lsCNF :: CNF t -> [t]\\
                Convert the disjunction back to a list of
                Literals.
        \item negateLit :: Ha hedge => Lit hedge -> Lit hedge\\
                Negate the truth value of a Literal
        \item smartCNF :: Ha hedge => [Lit hedge] -> CNF (Lit
                hedge)\\
                Sorts the list of Literals before construct a
                disjunction.
        \item sortCNF :: Ha hedge => CNF (Lit hedge) -> CNF (Lit
                hedge)\\
                Sort the Literals in a disjunction.
        \item sortLits :: Ha hedge => [Lit hedge] -> [Lit
                hedge]\\
                Sort the Literals in a list of Literals.
\end{itemize}

\subsection{Module AlphaResolution}
\subsubsection{Import and Export:}
\begin{lstlisting}
module AlphaResolution (
        smartClause,
        confidence,
        resolvent',
        resolution,
        nilH,
        Clause(..)
) where
import Data.List
import HedgeClass
import HedgeTruth
import ProsLogic
import Debug.Trace
\end{lstlisting}
\subsubsection{Description}
Implementation of the $\alpha-Resolution$ reasoning method.
\subsubsection{Internal Definition}
\begin{itemize}
        \item type Clause hedge = ([Lit hedge], Truth hedge)\\
                This type represents the Clause with confidence
                described in the resolution section in
                Theoretical Background chapter.
        \item nilH :: Ha hedge => Lit hedge\\
                This is the Nil literal, which is in turn used to 
                represent the Nil clause.
        \item smartClause :: Ha hedge => CNF (Lit hedge) -> Truth hedge ->
                Clause hedge\\
                Construct a Clause from a disjunction and a
                confidence value. The list of Literals in
                the disjunction is sorted .
        \item confidence :: Ha h => Truth h -> Truth h -> Truth h -> Truth h ->
                Truth h\\
                Formula for calculating confidence value from two
                clauses' confidence values and their resolved
                Literals' truth values.

        \item resolution' :: Ha hedge => [Clause hedge] ->
        %[(Clause hedge, Clause hedge)] ->
        [(Clause hedge, Clause hedge, Clause hedge)] -> [(String, Maybe t)] -> (Maybe (Truth
        hedge), [(Clause hedge, Clause hedge, Clause hedge)])\\
        The actual implementation of the $\alpha-Resolution$
        reasoning method. It takes a list of Clause to perform
        resolution on, an accummulated argument for the tracing
        list, a list of all ``sentences'' in the knowledge base
        and whether interpretation of each sentences is a
        positive truth value or not. It returns the resulting
        confidence value of the resolution process and the
        tracing list.\\\\
        The tracing list has the type of [(Clause hedge, Clause
        hedge, Clause hedge)], with the first Clause in each
        tuple being the resolvent, and the other two Clauses
        being the resolved Clauses.\\\\
        The list of all ``sentences'' and their interpretation's
        positivity is needed to correctly reduce the new Clauses
        obtained in the process of $\alpha-Resolution$, as
        discussed in the Theoretical Background section. While
        computing this list might sound costly, without it the
        search space for $\alpha-Resolution$ will be much larger
        and ultimately the whole process wil cost much more.\\        
        This list obtained by performing a first-pass
        classical resolution on the knowledge base, i.e we
        consider the knowledge base as if it was in classical
        propositional logic and perform normal resolution on it.
        We only care about whether each sentence is ``True'' or
        not, so this is sufficient.    
        


        \item resolution :: Ha hedge => [Clause hedge] -> (Maybe
         (Truth hedge), [(Clause hedge, Clause hedge, Clause
         hedge)])\\
                The interfacial method for using
                $\alpha-Resolution$. It takes a list of Clause
                and returns the confidence value of the
                resolution, and the tracing list to reconstruct
                the proof if needed.\\
                It is a wrapper around the
                actual implementation resolution', initializing
                some arguments of resolution' with appropriate
                values. 
\end{itemize}

\subsection{Module DBio.Hio}
\subsubsection{Import and Export:}
\begin{lstlisting}
module DBio.Hio(
  hManager,
  ) where
import SelfRestart
import Util.UtilB
import Database.HDBC
import Database.HDBC.Sqlite3
import Control.Monad
import Data.Char
import SelfRestart(selfRestart,exitImmediately,ExitCode(..))
import System.Environment(getProgName)
\end{lstlisting}
\subsubsection{Description}
This module defines the procedures to work with the hedges
definition in the knowledge base. 
\subsubsection{Internal Definition}
\begin{itemize}
        \item printlH :: IConnection conn => String -> conn -> IO
                ()\\ Generic hedges list print
              \begin{itemize}
               \item printPosH :: IConnection conn => conn -> IO ()\\
                     printNegH :: IConnection conn => conn -> IO ()\\
                     Specialized printing procedures for positive
                     and negative hedges lists.
              \end{itemize}         
             
      \item removeH :: String -> String -> IO ()\\
              Completely remove a hedge from the database
      \item removelH :: String -> String -> String -> IO ()
              Generic ``remove'' procedure to remove a hedge from
              a list
              \begin{itemize}
               \item removePosH :: String -> String -> IO ()
                     \\removeNegH :: String -> String -> IO ()\\
                     Specialized remove procedures for positive
                     and negative hedges lists
              \end{itemize}

      \item addlH :: String -> String -> String -> String -> String -> IO ()
            \\ Generic ``add new hedge'' procedure  
      \begin{itemize}
      \item addNegH :: String -> String -> String -> String -> IO ()
          \\addPosH :: String -> String -> String -> String -> IO ()
          \\ Specialized add procedures for positive
            and negative hedges lists
      \end{itemize}

      \item changeOrd :: String -> String -> String -> String -> IO ()
              \\Generic ``change order of hedges'' procedure
      \begin{itemize}
      \item changePosOrd :: String -> String -> String -> IO ()
         \\ changeNegOrd :: String -> String -> String -> IO ()
         \\ Specialized change order procedures for positive and negative
         hedges lists.
      \end{itemize}

      \item renameHedge :: String -> String -> String -> IO ()
       \\ rename a hedge in the database

      \item addlRel :: String -> String -> String -> String -> IO ()
              \\ Generic ``add new relation between hedges''
              procedure
      \begin{itemize}
      \item addPosRel :: String -> String -> String -> IO ()
          \\ addNegRel :: String -> String -> String -> IO ()
         \\ Specialized add relation procedures for positive and negative
         hedge relations lists.
      \end{itemize}

      \item removelRel :: String -> String -> String -> String -> IO ()
              \\ Generic ``remove a relation between hedges''
              procedure
      \begin{itemize}
      \item removePosRel :: String -> String -> String -> IO ()
        \\  removeNegRel :: String -> String -> String -> IO ()
         \\ Specialized remove relation procedures for positive and negative
         hedge relations lists.
      \end{itemize}

      \item hManager :: String -> IO ()\\
              \\ The interactive interface for managing hedges.
              This is the only exported procedure in this module,
              and the functionalities of other procedures can
              only be accessed through this procedure.
      \item printHedges :: String -> IO ()\\
              Print the hedge structure as currently defined in the
              knowledge base.
\end{itemize}
\subsection{Module DBio.KBio}
\subsubsection{Import and Export:}
\begin{lstlisting}
module DBio.KBio (
        cmenu,
        kbManager,
        parseGoals,
        getCNF) where
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution
import Util.UtilA
\end{lstlisting}
\subsubsection{Description}
This module provides the procedures to work with the knowledge
base's clauses, which internally have to process other entities
in the database that are hidden to the end user e.g. literals, hedge
strings, literals-clauses relationship.
\subsubsection{Internal Definition}
\begin{itemize}
        \item sid\_to\_hstring :: FilePath -> SqlValue -> IO
                [String]\\
                Transform a database's SID into its equivalent
                sequence of hedge name. This is used by the reasoning
                system to regenerate the truth value of a
                literal.                
        \item hStringtoHid :: String -> [String] -> IO (Maybe
                [SqlValue])\\
                Transform a sequence of hedge names to the equivalent
                list of database's HID, which is in turn used by find\_sid to
                recreate SID from a sequence of hedge names.
        \item find\_sid :: IConnection conn => conn -> ([SqlValue], SqlValue,
                 [SqlValue]) -> IO ([SqlValue], SqlValue,
                 [SqlValue])\\
                 Find the equivalent SID of a sequence of HID.
        \item insert\_if\_not\_exist\_sid :: String -> [Char] -> IO (Maybe
                 SqlValue)\\
                 Insert a SID for a string of hedges, if that
                 hasn't existed yet. Return the inserted SID or
                 Nothing.
        \item getCid :: String -> IO [String]\\
                Get a list of all CIDs in the database. This is
                used by getCNF to retrieve the list of all
                clauses in the database.
        \item getCNF :: String -> IO [CNF (Lit Hedge)]\\
                Retrieve the list of all clauses in the database
        \item parseGoal :: String -> Lit Hedge\\
                Parse a string into a Literal.
        \item parseGoals :: String -> [Lit Hedge]\\
                Apply parseGoal on a string of literals'
                representations, and parse it into a list of
                Literals.
        \item parseInpClause :: String -> [[String]]\\
                Break an input clause into a list of
                representations for its literals, each literal
                in turn is splitted into its sentence/symbol, its
                hedges string and its truth generating term.
        \item changeByCID :: String -> String -> String -> IO
                ()\\
                Change a clause by its CID.
        \item changeClause :: String -> [Char] -> String -> IO
                ()\\
                Change a clause by its formula. Internally use
                changeByCid
        \item deleteByCID :: String -> String -> IO ()\\
                Delete a clause by its CID
        \item deleteClause :: String -> [Char] -> IO ()\\
                Delete a clause by its formula. Internally use
                deleteByCID.
        \item addClause :: String -> [Char] -> IO ()\\
                Add a new clause by its formula
        \item kbManager :: String -> IO ()\\
                Interactive loop for knowledge base management
                use case
        \item cmenu :: [String] \\
                Menu for kbManager

\end{itemize}
\subsection{Module Util.UtilA}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Util.UtilA (
    okTruthStr,
    toClause,
    printClauses,
    printLits,
    prove,
    printHedges,    
    nil,
    headIs,
    findHead,
    retrace,
    module SelfRestart,
    module Util.UtilB, 
    module DBio.Hio
  ) where
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution

import Data.IORef
import Data.List.Split
import Data.Char

import Database.HDBC
import Database.HDBC.Sqlite3

import System.Environment
import System.Console.Readline

import Control.Concurrent
import Control.Monad
import Util.UtilB
import DBio.Hio
import SelfRestart (selfRestart,
forkSelfRestartExePollWithAction, exitImmediately, ExitCode(..))

\end{lstlisting}
\subsubsection{Description}
This module defines some commonly used small utilities that don't
really fit anywhere else. Only valid {\em after} Hedge is
defined. It also reexports a bunch of other modules for
convenience.
\subsubsection{Internal Definition}
\begin{itemize}
        \item okTruthStr :: [Char] -> Bool\\
         Check if a truth string is in proper format or not
        \item toClause :: Ha hedge => [CNF (Lit hedge)] ->
                [Clause hedge]\\
              Transform a CNF clause into a Clause.  
        \item printClauses :: Show a => [([a], t)] -> IO ()\\
                print a set of Clauses
%        \item printLits :: Ha hedge => [CNF (Lit hedge)] -> IO ()
        \item prove :: Ha hedge => [CNF (Lit hedge)] -> CNF (Lit hedge) ->
           (Maybe (Truth hedge), [(Clause hedge, Clause hedge, Clause hedge)])\\
            Wrapper around the alphaResolution function, it takes
            a knowledge base and a CNF clause, then return a pair
            consists of a Maybe value of confidence value, and a
            tracing list that can be used to recreate the proof.          
        \item printHedges :: FilePath -> IO ()\\
                print the hedges structure currently using in
                parallel with the one defined in the knowledge base. The FilePath
                parameter is meant for the path to the database
                file.
        \item nil :: [Lit Hedge]
                the nil Clause.
%        \item headIs :: Eq a => a -> (a, t, t1) -> Bool
%        \item findHead :: Eq a => a -> [(a, t, t1)] -> Maybe (a, t, t1)
        \item retrace :: (Eq t, Show t) => t -> [(t, t, t)] -> [t] -> [Char]
                recreate the proof from the trace.
\end{itemize}
\subsection{Module Util.UtilB}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Util.UtilB (
    properFormat,
    properTruthString,
    fromQuery,
    readline'
  ) where
import Data.IORef
import Data.List.Split
import Data.Char

import Database.HDBC
import Database.HDBC.Sqlite3

import System.Environment
import System.Console.Readline

import Control.Concurrent
import Control.Monad
\end{lstlisting}
\subsubsection{Description}
This module defines some commonly used small utilities that don't
fit anywhere else. Always available.
\subsubsection{Internal Definition}
\begin{itemize}
\item properFormat :: String -> String\\
        Transform a single word to proper format
\item properTruthString :: String -> [String]\\
        Transform a sentence into a list of properly formatted
        words.
\item fromQuery :: [[SqlValue]] -> [[String]]\\
        Convert the SqlValue results of SQL queries into Haskell
        value.
\item readline' :: IO String\\
        A wrapper for the library function readline. Used
        for getting interactive input in place of readline.
\end{itemize}
\subsection{Module Main}
\subsubsection{Import and Export:}
\begin{lstlisting}
module Main where
import Util.UtilA
import Util.UtilB
import DBio.KBio
import DBio.Hio
import ProsLogic
import Hedgen.Ahedge
import AlphaResolution
import Control.Exception
\end{lstlisting}
\subsubsection{Description}
This module simply defines the main IO loop to interact with the
user. This module is also the system's entry point of execution.
%\subsubsection{Internal Definition}

\section{Sample Execution of the System}
\paragraph{} As a final touch, this section will consider some
simple examples to illustrate the usage of the system.
\paragraph{} First, to get the system up and running, invoke {\em
runhaskell <db-file-name>} in the directory of the program:
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/openKB1}
  \caption{Illustration: invoking the reasoning system}
\end{figure}
\paragraph{} From this interaction loop, the user can make
command for the system as it is specified in the illustration.
For example, if the user wants to prove something, type ``prove'' in and press
enter. 
\subsection{Add, change and remove a clause}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/kb-manager}
  \caption{Illustration: Knowledge Base manager}
\end{figure}

\subsubsection{Add clause} 

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/example/add-clause}
  \caption{Illustration: Adding a new clause}
\end{figure}
To add a new clause, make the command ``add clause''
and enter the new clause. The clause must be a disjunction of
literals, and formatted as specified in the illustration.
Literals new to the KB will be added as needed.
Duplicated clause will be ignored.

\subsubsection{Change clause} 

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/example/change-clause}
  \caption{Illustration: Editing clause}
\end{figure}
To edit a clause, make the command ``change clause''
and enter the old and new clauses.
The system will do nothing if the new clause is in the KB or the
old clause doesn't exist.

\subsubsection{Delete clause} 

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/example/delete-clause}
  \caption{Illustration: Deleting clause}
\end{figure}
To remove a clause, make the command ``delete clause''
and enter the clause to be deleted.
The system will do nothing if the clause doesn't exist.

\subsection{Manage the underlying hedge algebra}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/hedge-manager}
  \caption{Illustration: Hedge algebra manager}
\end{figure}

\paragraph{} This system provides a range of operations to define and maintain
the hedge algebra that serves as the underlying truth value
domain the knowledge base, as depicted in the illustration. There
are something to keep in mind about using some of these
operations, but otherwise the usage is straightforward:
\begin{itemize}
  \item A hedge is either in positive or in negative list, but
    never both.
  \item When a hedge is removed from one of the two lists, it
    will still remain in the hedge table of the knowledge base.
    To remove it completely, invoke the ``rm hedge'' command.
  \item The positive and negative relations lists are always kept
    consistent by the system: every hedge has a specific relation
    to each other hedge, and there is no relation that is both
    positive and negative. For this reason, adding and removing
    a relation to/from a relations list at the same time moves
    that relation from/to the other relations list.
  \item The ``go back without reload'' option means that the
    system won't reload changes the user made to the hedge
    algebra, and just keep the old definition for the session (or
    until the user decides to reload). 
\end{itemize}

\subsection{An example of proving with $\alpha-Resolution$}
\paragraph{} Consider the knowledge base as illustrated below
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/scrshot/printkb}
  \caption{Example knowledge base}
\end{figure}
\paragraph{} The LSHA as the truth domain used to defined the
above knowledge base is $AX = \{X, G = {c^{+} = True, c^{-} =
False}, H = \{More, Very, Possibly, Less\}, \le\}$
\paragraph{} Where $H^{+} =
\{More, Very\}, More \le Very$, $H^{-} = \{Possibly, Less\},
Possibly \le Less$, and the relation matrix is defined as follows:
\begin{table}[H]
  \centering
\begin{tabular}{|l|c|c|c|c|}
\hline
            Affecting$\backslash$Affected & More & Very & Possibly & Less \\ \hline
            More                        & +    & +    & -    & -    \\ \hline
            Very                        & +    & +    & -    & +    \\ \hline
            Possibly                    & -    & -    & -    & -    \\ \hline
            Less                        & -    & -    & -    & -    \\ \hline
\end{tabular}
\caption {Another hedges relation matrix}
\end{table}
\paragraph{} Let Very, More, Possibly, Less be V, M, P, L for
short.


\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/example/prove1}
  \caption{Illustration: prove example}
\end{figure}
\paragraph{} Now suppose we want to prove G = 
``Spratly Islands is Vietnam's undisputable
territory''$^{VMTrue}$. To prove G, we will
perform resolution on $S = KB \cup \neg{G}$. 
To keep it convenient, let's call ``Vietnam has both legal and
historical proof of ownership over Spratly Islands'' A, ``China's
territorial claims have always been controversial'' B and
``Spratly Islands is Vietnam's undisputable territory'' C.

\paragraph{} Now let's try to perform normal resolution by hands
first. At the first glance, the easiest resolution proof
would be this one:

\[\qquad\qquad\qquad\cfrac{ C^{VMTrue},Maxt)  (B^{LFalse} \vee C^{PTrue}, Maxt) }
{\qquad\qquad\qquad\cfrac{ (B^{LFalse}, PTrue) (B^{VFalse} )  }
      {\qquad\qquad\qquad(NULL, LTrue)}}
\]
\paragraph{} So the confidence of this proof is Less True. 
\paragraph{} Now let's consider the proof using
$\alpha-resolution$.
Below is the limit set of clauses we get after doing
$\alpha-resolution$. The whole lengthy derivation process to get
there will be omitted for convenience.
\begin{enumerate}
        \item $(B^{MFalse}  \vee C^{ V M True} \vee A^{ V False}
                ,Maxt)$
        \item $(B^{LFalse} \vee C^{ P True},Maxt)$
        \item $(A^{ M V True},Maxt)$
        \item $(B^{ V True},Maxt)$
        \item $(C^{ V M False},Maxt)$
        \item $(B^{ M False} \vee C^{ V M True},V True)$
        \item $(C^{ V M True} \vee A^{ V False},M True)$
        \item $(B^{ M False} \vee A^{ V False},V M True)$
        \item $(C^{ P True},L True)$
        \item $(B^{ L False},P True)$
        \item $(C^{ V M True},M True)$
        \item $(B^{ M False},V M True)$
        \item $(A^{VFalse},MTrue)$
        \item $(NULL,M True)$
\end{enumerate}
\paragraph{} Let's
consider the $\alpha-Resolution$ proof of the system:
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/example/explain1}
  \caption{$\alpha-Resolution$ proof for the example}
\end{figure}
\paragraph{} As it shows here, the clauses used for proving
$C^{VMTrue}$ are all from the limit of the $\alpha-Resolution$,
and the result's confidence also concides with the NULL clause in the limit, which is
More True. 

\paragraph{} As a side note, one doesn't have to restrict himself
to query one single-literal clause, since the system accepts
conjunction of literals clause as its input for proving:
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{part2/example/prove2}
  \caption{Illustration: prove a conjunction of literals example}
\end{figure}
\end{document}
